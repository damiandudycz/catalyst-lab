#!/bin/bash

# ------------------------------------------------------------------------------
# Main functions:

# Load list of stages to build for every platform and release.
# Prepare variables used by the script for every stage.
# Sort stages based on their inheritance.
# Determine which stages to build.
# Insert virtual download stages for missing seeds.
load_stages() {
	[[ ${DEBUG} = true ]] && echo_color ${color_turquoise_bold} "[ Analizying stages ]" || echo -ne "# Analyzing stages..."

	declare -gA stages # Some details of stages retreived from scanning. (release,stage,target,source,has_parent).
	stages_count=0 # Number of all stages. Script will determine this value automatically.
	available_builds_files=$(find ${catalyst_builds_path} \( -type f -o -type l \) \( -name "*.tar.xz" -o -name "*.iso" \) -printf '%P\n')

	# Load basic details from platform.conf, release.conf and stage.spec files:
	# Find list of platforms. (ps3, rpi5, amd64, ...).
	readonly RL_VAL_PLATFORMS=$(get_directories ${templates_path})
	for platform in ${RL_VAL_PLATFORMS[@]}; do
		local platform_path=${templates_path}/${platform}

		# Load platform config. Saved to variables with platform_ prefix.
		for key in ${PLATFORM_KEYS[@]}; do unset ${key}; done
		source ${platform_path}/platform.conf
		for key in ${PLATFORM_KEYS[@]}; do eval platform_${key}=\${${key}}; done

		# Set platform_catalyst_conf variable for platform based on file existance.
		[[ -f ${platform_path}/catalyst.conf ]] && platform_catalyst_conf=${platform_path}/catalyst.conf || unset platform_catalyst_conf

		# Set platform arch variables (determined from platform_arch).
		local platform_basearch=${platform_arch%%/*}
		local platform_baseraw=$(basearch_to_baseraw ${platform_basearch})
		local platform_subarch=${platform_arch#*/}; platform_subarch=${platform_subarch:-${platform_basearch}}
		local platform_family=${ARCH_FAMILIES[${platform_basearch}]:-${platform_basearch}}
		local platform_interpreter=${ARCH_INTERPRETERS[${platform_baseraw}]:-/usr/bin/qemu-${platform_baseraw}} # Find correct arch_interpreter

		# Find list of releases in current platform. (23.0-default, 23.0-llvm, ...).
		RL_VAL_RELEASES=$(get_directories ${platform_path})
		for release in ${RL_VAL_RELEASES[@]}; do
			local release_path=${platform_path}/${release}

			for key in ${RELEASE_KEYS[@]}; do unset ${key}; done
			source ${release_path}/release.conf
			for key in ${RELEASE_KEYS[@]}; do eval release_${key}=\${${key}}; done

			# Set release_catalyst_conf variable for release based on file existance.
			[[ -f ${release_path}/catalyst.conf ]] && release_catalyst_conf=${release_path}/catalyst.conf || unset release_catalyst_conf

			# Find list of stages in current releass. (stage1-cell-base-openrc stage3-cell-base-openrc, ...)
			RL_VAL_RELEASE_STAGES=$(get_directories ${release_path})
			for stage in ${RL_VAL_RELEASE_STAGES[@]}; do
				[[ ${DEBUG} = true ]] && echo ${platform}/${release}/${stage}

				local stage_path=${templates_path}/${platform}/${release}/${stage}
				local stage_info_path=${stage_path}/stage.spec
				local stage_info_content=$(< ${stage_info_path})

				# Set stage_catalyst_conf variable for stage based on file existance.
				[[ -f ${stage_path}/catalyst.conf ]] && stage_catalyst_conf=${stage_path}/catalyst.conf || unset stage_catalyst_conf

				# Load values stored directly in stage.spec to stage dictionary
				declare -A stage_values=(); local key=""
				# Read the file
				while IFS= read -r line || [[ -n ${line} ]]; do
					line=$(echo ${line} | sed 's/#.*//; s/[[:space:]]*$//') # Remove comments and trim trailing whitespace
					[[ -z ${line} ]] && continue # Skip empty lines
					# Check if the line contains a new key
					if [[ ${line} =~ ^([a-zA-Z0-9_-]+):[[:space:]]*(.*) ]]; then
						key=${BASH_REMATCH[1]}
						value=${BASH_REMATCH[2]}
						stage_values[${key}]="${value}"
					elif [[ -n ${key} ]]; then
						stage_values[${key}]+=" $(echo ${line} | xargs)"
					fi
				done <<< ${stage_info_content}
				# Trim leading/trailing spaces:
				for key in ${!stage_values[@]}; do
					local value=$(echo ${stage_values[${key}]} | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
					stage_values[${key}]=${value}
				done

				# Prepare shared overwrites and computations of varialbles. These include properties for every possible stage type.
				# Only include here variables that might require special treament and the value will be the same for all target types.
				# If some property is different between different stage types, it will be set bellow.
				local _kind=${stage_values[kind]:-build} # If not specified, assume build.
				# Prepare variables that differ between kinds.
				if [[ ${_kind} = build ]]; then
					local _target=${stage_values[target]:-$(echo ${stage} | sed -E 's/(.*stage[0-9]+)-.*/\1/')} # Can be skipped in spec, will be determined from stage name
				elif [[ ${_kind} = download ]]; then
					local _target=${stage_values[target]:-$(echo ${stage} | sed -E 's/(.*stage[0-9]+)-.*/\1/')} # Can be skipped in spec, will be determined from stage name
				elif [[ ${_kind} = binhost ]]; then
					local _target=${stage_values[target]:-binhost}
				fi
				# Prepare variables with form shared between kinds.
				local _selected=$(is_stage_selected ${platform} ${release} ${stage})
				local _arch_emulation=$( [[ ${host_arch} = ${platform_basearch} ]] && echo false || echo true )
				local _subarch=${stage_values[subarch]:-${platform_subarch}} # Can be skipped in spec, will be determined from platform.conf
				local _repos=${stage_values[repos]:-${release_repos:-${platform_repos}}} # Can be definied in platform, release or stage (spec)
				local _cpu_flags=${stage_values[cpu_flags]:-${release_cpu_flags:-${platform_cpu_flags}}} # Can be definied in platform, release or stage (spec)
				local _releng_base=${stage_values[releng_base]:-${RELENG_BASES[${_target}]}} # Can be skipped in spec, will be determined automatically from target
				local _compression_mode=${stage_values[compression_mode]:-${release_compression_mode:-${platform_compression_mode:-pixz}}} # Can be definied in platform, release or stage (spec)
				local _catalyst_conf=${stage_values[catalyst_conf]:-${release_catalyst_conf:-${platform_catalyst_conf}}} # Can be added in platform, release or stage
				# Set and sanitize some of variables:
				local _rel_type=${stage_values[rel_type]:-${platform}/${release}}
				local _source_subpath=${stage_values[source_subpath]}
				local _binrepo=${stage_values[binrepo]:-${release_binrepo:-${platform_binrepo:-[local]${repos_cache_path}/local}}}
				local _binrepo_path=${stage_values[binrepo_path]:-${release_binrepo_path:-${platform_binrepo_path:-${_rel_type}}}}
				local _binrepo_fslimit=${stage_values[binrepo_fslimit]:-${release_binrepo_fslimit:-${platform_binrepo_fslimit}}}
				local _relrepo=${stage_values[relrepo]:-${release_relrepo:-${platform_relrepo}}}
				local _relrepo_path=${stage_values[relrepo_path]:-${release_relrepo_path:-${platform_relrepo_path:-${_rel_type}/@TIMESTAMP@}}}
				local _relrepo_path_metadata=${stage_values[relrepo_path_metadata]:-${release_relrepo_path_metadata:-${platform_relrepo_path_metadata:-${_rel_type}}}}
				local _relrepo_fslimit=${stage_values[relrepo_fslimit]:-${release_relrepo_fslimit:-${platform_relrepo_fslimit}}}
				local _version_stamp=${stage_values[version_stamp]:-$(echo ${stage} | sed -E 's/.*(^stage[1-4]|^livecd-stage[1-2]|^binhost)-(.*)/\2-@TIMESTAMP@/; t; s/.*/@TIMESTAMP@/')}
				local _product=${_rel_type}/${_target}-${_subarch}-${_version_stamp}
				local _product_format=${_product} # Stays the same the whole time, containing "@TIMESTAMP@" string for later comparsions
				local _product_iso=$([[ ${_target} = livecd-stage2 ]] && echo ${_rel_type}/${stage_values[iso]:-install-${_subarch}-@TIMESTAMP@} || echo "") # TODO: Use value from spec if set
				local _product_iso_format=${_product_iso} # Stays the same the whole time, containing "@TIMESTAMP@" string for later comparsions
				local _profile=${stage_values[profile]}
				# Sanitize selected variables
				local properties_to_sanitize=(rel_type version_stamp source_subpath product product_iso binrepo binrepo_path relrepo relrepo_path relrepo_path_metadata profile product_format product_iso_format)
				for key in ${properties_to_sanitize[@]}; do
					eval "_${key}=\$(sanitize_spec_variable ${platform} ${release} ${stage} ${platform_family} ${platform_basearch} ${_subarch} \"${_rel_type}\" \"\${_${key}}\")"
				done
				# Computed after sanitization of dependencies.
				local _available_builds=($(printf "%s\n" "${available_builds_files[@]}" | grep -E $(echo ${_product} | sed 's/@TIMESTAMP@/[0-9]{8}T[0-9]{6}Z/') | sort -r))
				local _available_isos=($( [[ -n ${_product_iso} ]] && printf "%s\n" "${available_builds_files[@]}" | grep -E $(echo ${_product_iso} | sed 's/@TIMESTAMP@/[0-9]{8}T[0-9]{6}Z/') | sort -r ))
				local _latest_build=$(echo "${_available_builds[@]}" | cut -d ' ' -f 1 | sed 's/\.tar\.xz$//') # Newest available
				local _latest_iso=$(echo "${_available_isos[@]}" | cut -d ' ' -f 1 | sed 's/\.iso$//') # Newest available
				local _latest_build_timestamp=$( [[ -n ${_latest_build} ]] && start_pos=$(expr index "${_product}" "@TIMESTAMP@") && echo "${_latest_build:$((start_pos - 1)):16}" )
				local _latest_iso_timestamp=$( [[ -n ${_latest_iso} ]] && start_pos=$(expr index "${_product_iso}" "@TIMESTAMP@") && echo "${_latest_iso:$((start_pos - 1)):16}" )
				# Load toml file from catalyst
				load_toml ${platform_basearch} ${_subarch} # Loading some variables directly from matching toml, if not specified in stage configs.
				# Compute after loading toml.
				local _chost=${stage_values[chost]:-${release_chost:-${TOML_CACHE[${platform_basearch},${_subarch},chost]}}} # Can be definied in platform, release or stage (spec). Otherwise it's taken from catalyst toml matching architecture
				local _common_flags=${stage_values[common_flags]:-${release_common_flags:-${TOML_CACHE[${platform_basearch},${_subarch},common_flags]}}} # Can be definied in platform, release or stage (spec)
				local _use=$(echo "${platform_use} ${release_use} ${stage_values[use]}" | sed 's/ \{1,\}/ /g' | sed 's/^[[:space:]]*//; s/[[:space:]]*$//') # For USE flags, we combine all the values from platform, release and stage. Toml flags are added only for binhost, as for stages, catalyst takes care of that.
				local _use_toml="${TOML_CACHE[${platform_basearch},${_subarch},use]}"

				# Apply modified properties to stage config entry:
				# Non modified entries, directly from platform, release or stage settings:
				stages[${stages_count},platform]=${platform}
				stages[${stages_count},release]=${release}
				stages[${stages_count},stage]=${stage}
				stages[${stages_count},arch_basearch]=${platform_basearch}
				stages[${stages_count},arch_baseraw]=${platform_baseraw}
				stages[${stages_count},arch_family]=${platform_family}
				stages[${stages_count},arch_interpreter]=${platform_interpreter}
				stages[${stages_count},treeish]=${stage_values[treeish]} # At this point it could be empty. Will be set automatically later.
				stages[${stages_count},packages]=${stage_values[packages]}
				# Modified entries, that can be adjusted by the script:
				stages[${stages_count},kind]=${_kind}
				stages[${stages_count},target]=${_target}
				stages[${stages_count},source_subpath]=${_source_subpath}
				stages[${stages_count},selected]=${_selected}
				stages[${stages_count},arch_emulation]=${_arch_emulation}
				stages[${stages_count},arch_subarch]=${_subarch}
				stages[${stages_count},repos]=${_repos}
				stages[${stages_count},chost]=${_chost}
				stages[${stages_count},common_flags]=${_common_flags}
				stages[${stages_count},cpu_flags]=${_cpu_flags}
				stages[${stages_count},use]=${_use}
				stages[${stages_count},use_toml]=${_use_toml}
				stages[${stages_count},releng_base]=${_releng_base}
				stages[${stages_count},compression_mode]=${_compression_mode}
				stages[${stages_count},binrepo]=${_binrepo}
				stages[${stages_count},binrepo_path]=${_binrepo_path}
				stages[${stages_count},binrepo_fslimit]=${_binrepo_fslimit}
				stages[${stages_count},relrepo]=${_relrepo}
				stages[${stages_count},relrepo_path]=${_relrepo_path}
				stages[${stages_count},relrepo_path_metadata]=${_relrepo_path_metadata}
				stages[${stages_count},relrepo_fslimit]=${_relrepo_fslimit}
				stages[${stages_count},version_stamp]=${_version_stamp}
				stages[${stages_count},catalyst_conf]=${_catalyst_conf}
				stages[${stages_count},rel_type]=${_rel_type}
				stages[${stages_count},product]=${_product}
				stages[${stages_count},product_format]=${_product_format}
				stages[${stages_count},product_iso]=${_product_iso}
				stages[${stages_count},product_iso_format]=${_product_iso_format}
				stages[${stages_count},profile]=${_profile}
				stages[${stages_count},latest_build]=${_latest_build}
				stages[${stages_count},timestamp_latest]=${_latest_build_timestamp}
				stages[${stages_count},latest_iso]=${_latest_iso}
				stages[${stages_count},timestamp_iso_latest]=${_latest_iso_timestamp}

				# Increase processed stages count.
				stages_count=$((stages_count + 1))
			done
		done
	done

	# Find initial parents here and use this indexes later to calculate other parameters
	update_parent_indexes

	# Generate virtual stages to download seeds for stages without local parents.
	declare added_download_stages=()
	declare -A added_download_stages_indexes=()
	local i; for (( i=0; i<${stages_count}; i++ )); do
		# Skip for builds other than local and binhost
		[[ ${stages[${i},kind]} != build ]] && [[ ${stages[${i},kind]} != binhost ]] && continue
		# Skip if found local parent stage.
		[[ -n ${stages[${i},parent]} ]] && continue

		local seed_subpath=${stages[${i},source_subpath]}
		if ! contains_string added_download_stages[@] ${seed_subpath}; then
			added_download_stages+=(${seed_subpath})
			added_download_stages_indexes[${seed_subpath}]=${stages_count}
			stages[${stages_count},kind]=download
			stages[${stages_count},product]=${seed_subpath}
			stages[${stages_count},product_format]=${seed_subpath}
			stages[${stages_count},platform]=${stages[${i},arch_family]} # Use arch family as platform for virtual remote jobs
			stages[${stages_count},release]=gentoo # Use constant name gentoo for virtual download stages
			stages[${stages_count},stage]=$(echo ${stages[${stages_count},product]} | awk -F '/' '{print $NF}' | sed 's/-@TIMESTAMP@//') # In virtual downloads, stage is determined this way
			stages[${stages_count},target]=$(echo ${stages[${stages_count},stage]} | sed -E 's/(.*stage[0-9]+)-.*/\1/')
			local _is_selected=$(is_stage_selected ${stages[${stages_count},platform]} ${stages[${stages_count},release]} ${stages[${stages_count},stage]})
			stages[${stages_count},selected]=$(is_stage_selected ${stages[${stages_count},platform]} ${stages[${stages_count},release]} ${stages[${stages_count},stage]})
			# Find available build
			local _available_builds=($(printf "%s\n" "${available_builds_files[@]}" | grep -E $(echo ${seed_subpath} | sed 's/@TIMESTAMP@/[0-9]{8}T[0-9]{6}Z/') | sort -r))
			local _latest_build=$(echo "${_available_builds[@]}" | cut -d ' ' -f 1 | sed 's/\.tar\.xz$//')
			local _latest_build_timestamp=$( [[ -n ${_latest_build} ]] && start_pos=$(expr index "${seed_subpath}" "@TIMESTAMP@") && echo "${_latest_build:$((start_pos - 1)):16}" )
			stages[${stages_count},latest_build]=${_latest_build}
			stages[${stages_count},timestamp_latest]=${_latest_build_timestamp}
			# Save interpreter and basearch as the same as the child that this new seed produces. In theory this could result in 2 or more stages using the same source while haveing different base architecture, but this should not be the case in properly configured templates.
			stages[${stages_count},arch_interpreter]=${stages[${i},arch_interpreter]}
			stages[${stages_count},arch_basearch]=${stages[${i},arch_basearch]}
			stages[${stages_count},arch_baseraw]=${stages[${i},arch_baseraw]}
			stages[${stages_count},arch_family]=${stages[${i},arch_family]}
			# Inferred rel_type.
			stages[${stages_count},rel_type]=${stages[${stages_count},arch_family]}/${stages[${stages_count},release]}
			# Emulation mode. For download stages, it's not gonna be used, but it's still determined in case some other functionalities uses this stages directly.
			local _emulation=$( [[ ${host_arch} = ${stages[${stages_count},arch_basearch]} ]] && echo false || echo true )
			stages[${stages_count},arch_emulation]=${_emulation}
			# Generate seed information download URL
			local seeds_arch_url=$(echo ${seeds_url} | sed "s/@ARCH_FAMILY@/${stages[${stages_count},arch_family]}/")
			stages[${stages_count},url]=${seeds_arch_url}/latest-${stages[${stages_count},stage]}.txt

			((stages_count++))
		fi
		stages[${i},parent]=${added_download_stages_indexes[${seed_subpath}]}
	done
	unset added_download_stages

	# Sort stages array by inheritance:
	declare stages_order=() # Order in which stages should be build, for inheritance to work. (1,5,2,0,...).
	# Prepare stages order by inheritance.
	local i; for (( i=0; i<${stages_count}; i++ )); do
		insert_stage_with_inheritance ${i}
	done
	# Store stages by inheritance order in temp array.
	declare -A stages_temp
	local i; for (( i=0; i<${stages_count}; i++ )); do
		local index=${stages_order[${i}]}
		for key in ${STAGE_KEYS[@]}; do
			stages_temp[${i},${key}]=${stages[${index},${key}]}
		done
	done
	# Write sorted array back to stages array.
	local i; for (( i=0; i<${stages_count}; i++ )); do
		for key in ${STAGE_KEYS[@]}; do
			stages[${i},${key}]=${stages_temp[${i},${key}]}
		done
	done
	unset stages_order
	unset stages_temp

	# Refresh parent indexes after sorting array.
	update_parent_indexes

	# Determine inherited profiles
	local i; for (( i=0; i<${stages_count}; i++ )); do
		[[ -n ${stages[${i},profile]} ]] && continue
		[[ -z ${stages[${i},arch_subarch]} ]] && continue
		stages[${i},profile]=$(sanitize_spec_variable ${stages[${i},platform]} ${stages[${i},release]} ${stages[${i},stage]} ${stages[${i},arch_family]} ${stages[${i},arch_basearch]} ${stages[${i},arch_subarch]} ${stages[${i},rel_type]} $(inherit_profile ${i}))
	done

	# Determine stages children array.
	local i; for (( i=0; i<${stages_count}; i++ )); do
		local j; for (( j=((i+1)); j<${stages_count}; j++ )); do
			if [[ ${stages[${j},parent]} = ${i} ]]; then
				stages[${i},children]="${stages[${i},children]} ${j}"
			fi
		done
		# Trim white spaces
		stages[${i},children]=${stages[${i},children]#${stages[${i},children]%%[![:space:]]*}}
	done

	# Determine rebuild property.
	for ((i=$((stages_count - 1)); i>=0; i--)); do
		# If selected, then rebuild. Note: || [[ ${stages[${i},rebuild]} = true ]] is intentional, makes sure whole parent's tree get's checked.
		if [[ ${stages[${i},selected]} = true ]] || [[ ${stages[${i},rebuild]} = true ]]; then
			stages[${i},rebuild]=true
			# Also mark parent as rebuild, it there's no available previous build for it.
			local parent_index=${stages[${i},parent]}
			if [[ -n ${parent_index} ]] && ( [[ -z ${stages[${parent_index},latest_build]} ]] || [[ ${CLEAN_BUILD} = true ]] ); then
				stages[${parent_index},rebuild]=true
			fi
			continue
		elif [[ ${stages[${i},rebuild]} != true ]]; then
			stages[${i},rebuild]=false
		fi
	done

	# Determine takes_part property.
	for ((i=$((stages_count - 1)); i>=0; i--)); do
		if [[ $(is_taking_part_in_rebuild ${i}) = true ]]; then
			stages[${i},takes_part]=true
		else
			stages[${i},takes_part]=false
		fi
	done

	[[ ${DEBUG} = true ]] && echo "" || echo -ne "\r"

	if [[ ${stages_count} -le 0 ]]; then
		if [[ ${#selected_stages_templates[@]} -eq 0 ]]; then
			echo_color ${color_red} "Templates not found in /etc/catalyst-lab/templates"
		else
			echo_color ${color_red} "Matching templates not found in /etc/catalyst-lab/templates"
		fi
		exit 1
	fi

	# List stages to build
	echo_color ${color_turquoise_bold} "[ Stages taking part in this process ]"
	draw_stages_tree
	echo ""

	# Determine timestamp_generated property - only for local for now.
	# For download this is filled after checking available download build.
	for ((i=$((stages_count - 1)); i>=0; i--)); do
		( [[ ${stages[${i},rebuild]} = false ]] || [[ ${stages[${i},kind]} = download ]] ) && continue
		stages[${i},timestamp_generated]=${timestamp}
	done
}

# Check if tools required for all rebuild stages are installed
validate_stages() {
	[[ ${DEBUG} = true ]] && echo_color ${color_turquoise_bold} "[ Stages sanity checks ]"

	# Prepare additional checks
	local required_checks=""
	for ((i=$((stages_count - 1)); i>=0; i--)); do
		[[ ${stages[${i},rebuild]} = false ]] && continue
		[[ ${stages[${i},kind]} = binhost ]] && [[ ! ${required_checks} == *"squashfs_tools_is_installed"* ]] && required_checks+="squashfs_tools_is_installed "
		if [[ ${stages[${i},arch_emulation]} = true ]]; then
			if [[ ! ${required_checks} == *"qemu_is_installed"* ]]; then
				required_checks+="qemu_is_installed qemu_has_static_user qemu_binfmt_is_running "
			fi
			# Create sanity checks for existance of all required interpreters.
			for interpreter in ${stages[${i},arch_interpreter]}; do
				local interpreter_var_name=$(echo ${interpreter} | sed 's/[\/-]/_/g')
				if [[ ! ${required_checks} == *"qemu_interpreter_installed${interpreter_var_name}"* ]]; then
					eval "qemu_interpreter_installed${interpreter_var_name}=$( [[ -f ${interpreter} ]] && echo true || echo false )"
					required_checks+="qemu_interpreter_installed${interpreter_var_name} "
				fi
			done
		fi
		if [[ $(repo_kind ${stages[${i},relrepo]}) = git ]]; then
			if [[ ! ${required_checks} == *"git_lfs_is_installed"* ]]; then
				required_checks+="git_lfs_is_installed "
			fi
		fi
		# Check if some of repos require git
		local repos=(${stages[${i},repos]} ${stages[${i},relrepo]} ${stages[${i},binrepo]})
		for repo in ${repos[@]}; do
			if [[ $(repo_kind ${repo}) = git ]]; then
				if [[ ! ${required_checks} == *"git_is_installed"* ]]; then
					required_checks+="git_is_installed "
				fi
			fi
		done
	done

	# Run checks.
	if [[ -n ${required_checks[@]} ]]; then
		validate_sanity_checks false "${DEBUG}" "${required_checks}"
	fi

	[[ ${DEBUG} = true ]] && echo ""
}

#  Get portage snapshot version and download new if needed.
prepare_portage_snapshot() {
	if [[ -d ${catalyst_path}/snapshots && $(find ${catalyst_path}/snapshots -type f -name "*.sqfs" | wc -l) -gt 0 ]]; then
		treeish=$(find ${catalyst_path}/snapshots -type f -name "*.sqfs" -exec ls -t {} + | head -n 1 | xargs -n 1 basename -s .sqfs | cut -d '-' -f 2)
	fi
	if [[ -z ${treeish} ]] || [[ ${FETCH_FRESH_SNAPSHOT} = true ]]; then
		echo_color ${color_turquoise_bold} "[ Refreshing portage snapshot ]"
		catalyst -s stable || exit 1
		treeish=$(find ${catalyst_path}/snapshots -type f -name "*.sqfs" -exec ls -t {} + | head -n 1 | xargs -n 1 basename -s .sqfs | cut -d '-' -f 2)
		echo "" # New line
	fi
}

# Get latest releng release if needed.
prepare_releng() {
	# If releng directory doesn't exists - download new version
	# If it exists and FETCH_FRESH_RELENG is set, pull changes.
	if [[ ! -d ${releng_path} ]]; then
		echo_color ${color_turquoise_bold} "[ Downloading releng ]"
		git clone https://github.com/gentoo/releng.git ${releng_path} --depth 1 || { echo_color ${color_red} "Failed to clone repository. Check if you have required access." && return 1; }
		echo ""
	elif [[ ${FETCH_FRESH_RELENG} = true ]]; then
		echo_color ${color_turquoise_bold} "[ Updating releng ]"
		git -C ${releng_path} pull || { echo_color ${color_red} "Failed to pull repository. Check if you have required access." && return 1; }
		echo ""
	fi
}

fetch_repos() {
	echo_color ${color_turquoise_bold} "[ Preparing remote repositories ]"

	# Collect repositories to fetch from repos, release_repos and binrepos
	local all_repos=()
	local i; for (( i=0; i<${stages_count}; i++ )); do
		[[ ${stages[${i},rebuild]} = false ]] && continue
		local stage_repos=(${stages[${i},repos]} ${stages[${i},binrepo]} ${stages[${i},relrepo]})
		for repo in ${stage_repos[@]}; do
			if ! contains_string all_repos[@] ${repo}; then
				all_repos+=(${repo})
			fi
		done
	done

	# Fetch remote repos
	local handled_repos=()
	for repo in ${all_repos[@]}; do
		local repo_kind=$(repo_kind ${repo})
		local repo_local_path=$(repo_local_path ${repo})
		local repo_url=$(repo_url ${repo})
		contains_string handled_repos[@] ${repo_local_path} && continue
		handled_repos+=(${repo_local_path})
		# Check if is remote repository and process in correct way
		case ${repo_kind} in
			git)
				if [[ ! -d ${repo_local_path}/.git ]]; then
					# If location doesn't exists yet - clone repository
					echo -e "${color_turquoise}Clonning repo: ${color_yellow}${repo_url}${color_nc}"
					mkdir -p ${repo_local_path}
					git clone ${repo_url} ${repo_local_path} --depth 1 || { echo_color ${color_red} "Failed to clone repository. Check if you have required access." && exit 1; }
					echo ""
				elif [[ ${FETCH_FRESH_REPOS} = true ]]; then
					# If it exists - pull repository
					echo -e "${color_turquoise}Pulling repo: ${color_yellow}${repo_url}${color_nc}"
					git -C ${repo_local_path} pull || { echo_color ${color_red} "Failed to pull repository. Check if you have required access." && exit 1; }
					echo ""
				fi
				;;
			rsync)
				echo -e "${color_turquoise}Syncing repo: ${color_yellow}${repo_url}${color_nc}"
				[[ ! -d ${repo_local_path} ]] && mkdir -p ${repo_local_path}
				rsync ${RSYNC_OPTIONS} ${ssh_username}@${repo_url}/ ${repo_local_path}/ || { echo_color ${color_red} "Failed to sync repository. Check if you have required access." && exit 1; }
				echo ""
				;;
			local) ;; # Skip local binrepos
			*)
				echo_color ${color_red} "Error! Unsupported repo type: ${repo_kind} (${repo_url})"
				echo ""
				;;
		esac
	done

	echo_color ${color_green} "Remote repositories prepared" && echo ""
}

# Setup additional information for stages:
# Final download URL's.
# Real seed names, with timestamp replaced.
# Write files stages to tmp.
prepare_stages() {
	echo_color ${color_turquoise_bold} "[ Preparing stages ]"

	local i; for (( i=0; i<${stages_count}; i++ )); do
		# Prepare only stages that needs rebuild.
		if [[ ${stages[${i},rebuild]} = true ]]; then
			# Update treeish property for local builds and binhosts.
			( [[ ${stages[${i},kind]} = build ]] || [[ ${stages[${i},kind]} = binhost ]] ) && stages[${i},treeish]=${stages[${i},treeish]:-${treeish}}

			# Prepare download builds newest timestamp and url from backend.
			if [[ ${stages[${i},kind]} = download ]]; then
				echo -e "${color_turquoise}Getting seed info: ${color_yellow}${stages[${i},platform]}/${stages[${i},release]}/${stages[${i},stage]}${color_nc}"
				local metadata_content=$(wget -q -O - ${stages[${i},url]} --no-http-keep-alive --no-cache --no-cookies)
				local stage_regex=${stages[${i},stage]}"-[0-9]{8}T[0-9]{6}Z"
				local latest_seed=$(echo "${metadata_content}" | grep -E ${stage_regex} | head -n 1 | cut -d ' ' -f 1)
				local arch_url=$(echo ${seeds_url} | sed "s/@ARCH_FAMILY@/${stages[${i},arch_family]}/")
				# Replace URL from metadata url to stage download url
				stages[${i},url]=${arch_url}/${latest_seed}
				# Extract download available timestamp and store it in stage timestamp_generated
				stages[${i},timestamp_generated]=$(echo ${latest_seed} | sed -n -r "s|.*${stages[${i},stage]}-([0-9]{8}T[0-9]{6}Z).*|\1|p")
			fi
		fi

		# Fill timestamps in stages.
		local stage_timestamp=${stages[${i},timestamp_generated]:-${stages[${i},timestamp_latest]}}
		if [[ -n ${stage_timestamp} ]]; then
			# Update stage_timestamp in product and version_stamp of this target
			stages[${i},product]=$(echo ${stages[${i},product]} | sed "s|@TIMESTAMP@|${stage_timestamp}|")
			stages[${i},product_iso]=$(echo ${stages[${i},product_iso]} | sed "s|@TIMESTAMP@|${stage_timestamp}|")
			stages[${i},version_stamp]=$(echo ${stages[${i},version_stamp]} | sed "s|@TIMESTAMP@|${stage_timestamp}|")
			# Update childrent source_subpath timestamp
			for child in ${stages[${i},children]}; do
				stages[${child},source_subpath]=$(echo ${stages[${child},source_subpath]} | sed "s|@TIMESTAMP@|${stage_timestamp}|")
			done
		fi
	done

	mkdir -p ${work_path}
	mkdir -p ${work_path}/jobs
	mkdir -p ${work_path}/binhosts

	local i; local j=0; for (( i=0; i<${stages_count}; i++ )); do
		[[ ${stages[${i},rebuild]} = false ]] && continue
		((j++))

		# Create stages final files - spec, catalyst.conf, portage_confdir, root_overlay, overlay, fstype and download job scripts.
		# Treat download and build jobs differently here.

		local platform_path=${templates_path}/${stages[${i},platform]}
		local platform_path_work=${work_path}/${stages[${i},platform]}
		local release_path=${platform_path}/${stages[${i},release]}
		local release_path_work=${platform_path_work}/${stages[${i},release]}
		local stage_path=${release_path}/${stages[${i},stage]}
		local stage_path_work=${release_path_work}/${stages[${i},stage]}
		local spec_link_work=$(printf ${work_path}/jobs/%03d.${stages[${i},platform]}-${stages[${i},release]}-${stages[${i},stage]} ${j})
		local portage_path_work=${stage_path_work}/portage

		# Prepare repos_local_paths
		local repos_local_paths=()
		for repo in ${stages[${i},repos]}; do
			repos_local_paths+=($(repo_local_path ${repo}))
		done

		# Copy stage template workfiles to work_path. For virtual stages, just create work directory (virtual stages don't have existing stage_path directory).
		mkdir -p ${stage_path_work}
		if [[ -d ${stage_path} ]]; then
			cp -rf ${stage_path}/* ${stage_path_work}/
		fi

		if [[ ${stages[${i},kind]} = build ]]; then

			# Setup used paths:
			local catalyst_conf_work=${stage_path_work}/catalyst.conf
			local stage_overlay_path_work=${stage_path_work}/overlay
			local stage_root_overlay_path_work=${stage_path_work}/root_overlay
			local stage_fsscript_path_work=${stage_path_work}/fsscript.sh
			local stage_info_path_work=${stage_path_work}/stage.spec
			local target_mapping=${TARGET_MAPPINGS[${stages[${i},target]}]:-${stages[${i},target]}}
			local stage_pkgcache_path=$(repo_local_path ${stages[${i},binrepo]})/${stages[${i},binrepo_path]}

			# Create new portage_work_path if doesn't exists.
			mkdir -p ${portage_path_work}

			# Prepare portage enviroment - Combine base portage files from releng with stage template portage files.
			if [[ -n ${stages[${i},releng_base]} ]]; then
				local interpreter_portage_postfix=$( [[ ${stages[${i},arch_emulation]} = true ]] && echo -qemu )
				local releng_base_dir=${releng_path}/releases/portage/${stages[${i},releng_base]}${interpreter_portage_postfix}
				cp -ru ${releng_base_dir}/* ${portage_path_work}/
			fi

			# Set 00cpu-flags file if used.
			if [[ -n ${stages[${i},cpu_flags]} ]]; then
				local package_use_path_work=${portage_path_work}/package.use
				mkdir -p ${package_use_path_work}
				echo "*/* "${stages[${i},cpu_flags]} > ${package_use_path_work}/00cpu-flags
			fi

			# Copy custom catalyst.conf if used.
			if [[ -n ${stages[${i},catalyst_conf]} ]]; then
				cp ${stages[${i},catalyst_conf]} ${catalyst_conf_work}
				# Update NPROC value in used catalyst_conf.
				sed -i "s|@JOBS@|${jobs}|g" ${catalyst_conf_work}
				sed -i "s|@LOAD_AVERAGE@|${load_average}|g" ${catalyst_conf_work}
				sed -i "s|@TMPFS_SIZE@|${tmpfs_size}|g" ${catalyst_conf_work}
			fi

			# Replace spec templates with real data:
			echo "" >> ${stage_info_path_work} # Add new line, to separate new entries
			echo "# Added by catalyst-lab" >> ${stage_info_path_work}

			set_spec_variable ${stage_info_path_work} source_subpath ${stages[${i},source_subpath]} # source_subpath shoud always be replaced with calculated value, to take into consideration existing old builds usage.

			set_spec_variable_if_missing ${stage_info_path_work} target ${stages[${i},target]}
			set_spec_variable_if_missing ${stage_info_path_work} profile ${stages[${i},profile]}
			set_spec_variable_if_missing ${stage_info_path_work} rel_type ${stages[${i},rel_type]}
			set_spec_variable_if_missing ${stage_info_path_work} subarch ${stages[${i},arch_subarch]}
			set_spec_variable_if_missing ${stage_info_path_work} version_stamp ${stages[${i},version_stamp]}
			set_spec_variable_if_missing ${stage_info_path_work} snapshot_treeish ${stages[${i},treeish]}
			set_spec_variable_if_missing ${stage_info_path_work} portage_confdir ${portage_path_work}
			set_spec_variable_if_missing ${stage_info_path_work} pkgcache_path ${stage_pkgcache_path}

			update_spec_variable ${stage_info_path_work} TIMESTAMP ${stages[${i},timestamp_generated]}
			update_spec_variable ${stage_info_path_work} PLATFORM ${stages[${i},platform]}
			update_spec_variable ${stage_info_path_work} RELEASE ${stages[${i},release]}
			update_spec_variable ${stage_info_path_work} TREEISH ${stages[${i},treeish]}
			update_spec_variable ${stage_info_path_work} FAMILY_ARCH ${stages[${i},arch_family]}
			update_spec_variable ${stage_info_path_work} BASE_ARCH ${stages[${i},arch_basearch]}
			update_spec_variable ${stage_info_path_work} SUB_ARCH ${stages[${i},arch_subarch]}
			update_spec_variable ${stage_info_path_work} PKGCACHE_BASE_PATH ${pkgcache_base_path}

			# releng portage_prefix.
			if [[ -n ${stages[${i},releng_base]} ]]; then
				set_spec_variable_if_missing ${stage_info_path_work} portage_prefix releng
			fi

			# Clear properties not used in final spec.
			local properties_to_clear=(kind releng_base)
			for key in ${properties_to_clear[@]}; do
				sed -i "/^${key}:/d" ${stage_info_path_work}
			done

			# Create customized fsscript if parent used different profile.
			if [[ ${stages[${i},target]} = stage4 ]]; then
				if [[ ! ${stages[${stages[${i},parent]},profile]} = ${stages[${i},profile]} ]] && [[ -n ${stages[${stages[${i},parent]},profile]} ]]; then
					[[ ! -f ${stage_fsscript_path_work} ]] && touch ${stage_fsscript_path_work} # Create if doesnt exists
					cat <<EOF | sed 's/^[ \t]*//g' | tee -a ${stage_fsscript_path_work} > /dev/null
						# Rebuild @world to make sure profile changes are included
						emerge --changed-use --update --deep --usepkg --buildpkg --with-bdeps=y --color=y --quiet @world
						emerge --depclean --color=y
EOF
				fi
			fi

			[[ -n ${stages[${i},common_flags]} ]] && set_spec_variable_if_missing ${stage_info_path_work} common_flags "${stages[${i},common_flags]}"
			[[ ${stages[${i},arch_emulation]} = true ]] && set_spec_variable_if_missing ${stage_info_path_work} interpreter "${stages[${i},arch_interpreter]}"
			[[ -d ${stage_overlay_path_work} ]] && set_spec_variable_if_missing ${stage_info_path_work} overlay ${stage_overlay_path_work}
			[[ -d ${stage_root_overlay_path_work} ]] && set_spec_variable_if_missing ${stage_info_path_work} root_overlay ${stage_root_overlay_path_work}
			[[ -f ${stage_fsscript_path_work} ]] && set_spec_variable_if_missing ${stage_info_path_work} fsscript ${stage_fsscript_path_work}
			[[ -n ${repos_local_paths} ]] && set_spec_variable_if_missing ${stage_info_path_work} repos "${repos_local_paths[@]}"

			# Special variables for only some stages:

			# Update seed.
			if [[ ${stages[${i},target]} = stage1 ]]; then
				set_spec_variable_if_missing ${stage_info_path_work} update_seed yes
				set_spec_variable_if_missing ${stage_info_path_work} update_seed_command "--changed-use --update --deep --usepkg --buildpkg --with-bdeps=y --color=y @system @world"
			fi

			# LiveCD - stage1 specific default values.
			if [[ ${stages[${i},target]} = livecd-stage1 ]]; then
				[[ -n ${stages[${i},use]} ]] && set_spec_variable ${stage_info_path_work} use "${stages[${i},use]}"
			fi

			# LiveCD - stage2 specific default values.
			if [[ ${stages[${i},target]} = livecd-stage2 ]]; then
				set_spec_variable_if_missing ${stage_info_path_work} type gentoo-release-minimal
				set_spec_variable_if_missing ${stage_info_path_work} volid Gentoo_${stages[${i},platform]}
				set_spec_variable_if_missing ${stage_info_path_work} fstype squashfs
				set_spec_variable_if_missing ${stage_info_path_work} iso $(basename ${stages[${i},product_iso]}).iso
			fi

			# Stage4 specific keys
			if [[ ${stages[${i},target]} = stage4 ]]; then
				set_spec_variable_if_missing ${stage_info_path_work} binrepo_path ${stages[${i},binrepo_path]}
				[[ -n ${stages[${i},use]} ]] && set_spec_variable ${stage_info_path_work} use "${stages[${i},use]}"
			fi

			if [[ -n ${stages[${i},chost]} ]] && [[ ${stages[${i},target]} = stage1 ]]; then # Only allow setting chost in stage1 targets.
				set_spec_variable_if_missing ${stage_info_path_work} chost ${stages[${i},chost]}
			fi

			if contains_string COMPRESSABLE_TARGETS[@] ${stages[${i},target]}; then
				set_spec_variable_if_missing ${stage_info_path_work} compression_mode ${stages[${i},compression_mode]}
			fi

			# Add target prefix to things like use, rcadd, unmerge, etc.
			for target_key in ${TARGET_KEYS[@]}; do
				sed -i "s|^${target_key}:|${target_mapping}/${target_key}:|" ${stage_info_path_work}
			done

			# Create links to spec files and optionally to catalyst_conf if using custom.
			ln -s ${stage_info_path_work} ${spec_link_work}.spec
			[[ -f ${catalyst_conf_work} ]] && ln -s ${catalyst_conf_work} ${spec_link_work}.catalyst.conf

		elif [[ ${stages[${i},kind]} = download ]]; then
			# Create stage for remote download:

			local download_script_path_work=${stage_path_work}/download.sh
			local download_path=${catalyst_builds_path}/${stages[${i},product]}.tar.xz
			local download_dir=$(dirname ${download_path})

			# Prepare download script for download job.
			cat <<EOF | sed 's/^[ \t]*//' | tee ${download_script_path_work} > /dev/null || exit 1
				#!/bin/bash
				file=${download_path}
				[[ -f \${file} ]] && echo 'File already exists' && exit
				mkdir -p ${download_dir}
				trap '[[ -f \${file} ]] && rm -f \${file}' EXIT SIGINT
				wget ${stages[${i},url]} -O \${file} --progress=dot:mega || exit 1
				trap - EXIT
EOF
			chmod +x ${download_script_path_work}

			# Create link to download script.
			ln -s ${download_script_path_work} ${spec_link_work}.sh

		elif [[ ${stages[${i},kind]} = binhost ]]; then
			# Create stage for building binhost packages.

			local binhost_script_path_work=${stage_path_work}/build-binpkgs.sh
			local source_tarball_path=${catalyst_builds_path}/${stages[${i},source_subpath]}.tar.xz
			local build_work_path=${binhost_work_path}/binhosts/${stages[${i},product]}
			local binrepo_path=$(repo_local_path ${stages[${i},binrepo]})/${stages[${i},binrepo_path]}

			# Create new portage_work_path if doesn't exists.
			mkdir -p ${portage_path_work}

			# Prepare portage enviroment - Combine base portage files from releng with stage template portage files.
			if [[ -n ${stages[${i},releng_base]} ]]; then
				local interpreter_portage_postfix=$( [[ ${stages[${i},arch_emulation]} = true ]] && echo -qemu )
				local releng_base_dir=${releng_path}/releases/portage/${stages[${i},releng_base]}${interpreter_portage_postfix}
				cp -ru ${releng_base_dir}/* ${portage_path_work}/
			fi

			# Set 00cpu-flags file if used.
			if [[ -n ${stages[${i},cpu_flags]} ]]; then
				local package_use_path_work=${portage_path_work}/package.use
				mkdir -p ${package_use_path_work}
				echo "*/* "${stages[${i},cpu_flags]} > ${package_use_path_work}/00cpu-flags
			fi

			# Load common_flags, use flags and chost from toml or from stage if set.
			local common_flags=${stages[${i},common_flags]}
			local chost=${stages[${i},chost]}
			local use=$(echo ${stages[${i},use_toml]} ${stages[${i},use]} | sed 's/ \{1,\}/ /g' | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')

			mkdir -p ${build_work_path}

			# Prepare build script for binhost job.
			cat <<EOF | sed 's/^[ \t]*//' | tee ${binhost_script_path_work} > /dev/null || exit 1
				#!/bin/bash

				# Cleanup build_work_path on exit.
				trap 'echo "Cleaning: ${build_work_path}"; rm -rf ${build_work_path}' EXIT

				echo "Extract ${source_tarball_path} to ${build_work_path}"
				tar -xpf ${source_tarball_path} -C ${build_work_path} || exit 1

				if [[ ${stages[${i},arch_emulation]} = true ]]; then
					for interpreter in ${stages[${i},arch_interpreter]}; do
						echo "Inject interpreter: \${interpreter}"
						cp \${interpreter} ${build_work_path}/usr/bin/ || exit 1
					done
				fi

				echo "Preparing portage directory"
				cp -ru ${portage_path_work}/* ${build_work_path}/etc/portage/ || exit 1

				# Set common-flags, chost and use flags.
				[[ -n "${common_flags}" ]] && { echo "Setting COMMON_FLAGS: ${common_flags}" && sed -i 's|^COMMON_FLAGS=.*$|COMMON_FLAGS="${common_flags}"|' ${build_work_path}/etc/portage/make.conf || exit 1; }
				[[ -n "${chost}" ]] && { echo "Setting CHOST: ${chost}" && sed -i 's|^CHOST=.*$|CHOST="${chost}"|' ${build_work_path}/etc/portage/make.conf || exit 1; }
				[[ -n "${use}" ]] && echo "Setting USE flags: ${use}" && echo "USE=\\"\\\${USE} ${use}\\"" >> ${build_work_path}/etc/portage/make.conf

				# Extract portage snapshot.
				echo "Preparing portage snapshot"
				unsquashfs -d ${build_work_path}/var/db/repos/gentoo ${catalyst_path}/snapshots/gentoo-${stages[${i},treeish]}.sqfs || exit 1

				echo "Preparing chroot environment"
				unshare --mount -- bash -c ${binhost_script_path_work}-unshare || exit 1
EOF
			chmod +x ${binhost_script_path_work}

			cat <<EOF | sed 's/^[ \t]*//' | tee ${binhost_script_path_work}-unshare > /dev/null || exit 1
				# Mount necessary filesystems
				echo "Mounting system directories"
				mkdir -p ${build_work_path}/{dev,dev/pts,proc,sys,run} || exit 1
				mount -t proc /proc ${build_work_path}/proc || exit 1
				mount -t sysfs /sys ${build_work_path}/sys || exit 1
				mount -t tmpfs tmpfs ${build_work_path}/run || exit 1
				mount -t devtmpfs devtmpfs ${build_work_path}/dev || exit 1
				mount -t devpts devpts ${build_work_path}/dev/pts || exit 1

				# Bind mount binrepo to /var/cache/binpkgs to allow using and building packages for the binrepo.
				echo "Binding binhost directory: ${binrepo_path}"
				[[ ! -e ${binrepo_path} ]] && { mkdir -p ${binrepo_path} || exit 1; } # If binrepo path doesn't exists, create it
				mkdir -p ${build_work_path}/var/cache/binpkgs || exit 1
				mount --bind ${binrepo_path} ${build_work_path}/var/cache/binpkgs || exit 1
				# Bind overlay repos.
				repo_mount_paths=''
				if [[ -n "${repos_local_paths}" ]]; then
					mkdir -p ${build_work_path}/etc/portage/repos.conf || exit
					for repo in ${repos_local_paths[@]}; do
						echo "Binding overlay repository: \${repo}"
						# Bind repo
						repo_name=\$(basename \${repo})
						repo_mount_path=${build_work_path}/var/db/repos/\${repo_name}
						mkdir -p \${repo_mount_path} || exit 1
						mount --bind \${repo} \${repo_mount_path} || exit 1
						# Register repo
						repo_info_path=${build_work_path}/etc/portage/repos.conf/\${repo_name}.conf
						repo_real_name=\$(cat \${repo}/profiles/repo_name)
						repo_real_name=\${repo_real_name:-\${repo_name}}
						echo "[\${repo_real_name}]" > \${repo_info_path}
						echo "location = /var/db/repos/\${repo_name}" >> \${repo_info_path}
						echo "masters = gentoo" >> \${repo_info_path}
						echo "auto-sync = no" >> \${repo_info_path}
						# Remember repo to unmount
						repo_mount_paths="\${repo_mount_paths},\${repo_mount_path}"
					done
				fi
				repo_mount_paths=$(echo "${repo_mount_paths}" | sed 's/^,//') # Remove leading ","

				# Bind mount resolv.conf for DNS resolution
				echo "Binding resolv.conf"
				[[ ! -f ${build_work_path}/etc/resolv.conf ]] && { touch ${build_work_path}/etc/resolv.conf || exit 1; }
				mount --bind /etc/resolv.conf ${build_work_path}/etc/resolv.conf || exit 1

				# Trap to ensure cleanup
				trap 'umount -l ${build_work_path}/{dev/pts,dev,proc,sys,run}; umount ${build_work_path}/var/cache/binpkgs; umount ${build_work_path}/etc/resolv.conf; [[ -n \${repo_mount_paths} ]] && umount \${repo_mount_paths}' EXIT

				# Insert binhost-run script into chroot and run it
				echo "Entering chroot environment"
				cp ${spec_link_work}-run.sh ${build_work_path}/run-binhost.sh || exit 1
				chroot ${build_work_path} /bin/bash -c /run-binhost.sh || exit 1
EOF
			chmod +x ${binhost_script_path_work}-unshare

			cat <<EOF | sed 's/^[ \t]*//' | tee ${binhost_script_path_work}-run > /dev/null || exit 1
				# Change profile
				if [[ -n "${stages[${i},profile]}" ]]; then
					echo "Changing profile: ${stages[${i},profile]}"
					eselect profile set ${stages[${i},profile]} || exit 1
				fi

				echo 'Searching for packages to rebuild...'
				declare packages_to_emerge=()

				emerge_args_analyze=(
					--buildpkg
					--usepkg
					--getbinpkg=n
					--changed-use
					--update
					--deep
					--keep-going
					--quiet
					--color=y
				)

				emerge_args_build=(
					--buildpkg
					--usepkg
					--getbinpkg=n
					--changed-use
					--update
					--deep
					--keep-going
					--quiet
					--verbose
					--color=y
				)

				for package in ${stages[${i},packages]}; do
					echo "Analyzing: \${package}"
					output=\$(emerge \${emerge_args_analyze[@]} \${package} -pv 2>&1)
					if [[ \$? -ne 0 ]]; then
						echo -e '${color_orange}Warning! '\${package}' fails to emerge. Adjust portage configuration. Skipping.${color_nc}'
						echo -e "\${output}"
						echo ""
						continue
					fi
					output=\$(echo "\${output}" | sed -r 's/\x1B\[[0-9;]*[a-zA-Z]//g') # Sed remove colors
					packages_to_emerge+=(\$(echo "\${output}" | grep "^\\[ebuild.*\\]" | sed -E "s/.*] ([^ ]+) .*/=\\1/"))
				done
				packages_to_emerge=(\$(echo \${packages_to_emerge[@]} | tr ' ' '\n' | sort -u | tr '\n' ' '))

				# Emerge only packages that don't have bin packages available
				if [[ \${#packages_to_emerge[@]} -gt 0 ]]; then
					echo -e 'Packages to rebuild:'
					for package in \${packages_to_emerge[@]}; do
						echo '  '\${package}
					done
					echo "Building packages"
					echo "emerge \${emerge_args[@]} \${packages_to_emerge[@]}"
					emerge \${emerge_args_build[@]} \${packages_to_emerge[@]} || exit 1
					echo -e "${color_green}All done${color_nc}"
				else
					echo -e "${color_green}Nothing to rebuild${color_nc}"
				fi
EOF
			chmod +x ${binhost_script_path_work}-run

			# Create link to build script.
			ln -s ${binhost_script_path_work} ${spec_link_work}.sh
			ln -s ${binhost_script_path_work}-unshare ${spec_link_work}-unshare.sh
			ln -s ${binhost_script_path_work}-run ${spec_link_work}-run.sh

		fi
	done

	echo_color ${color_green} "Stage templates prepared: ${work_path}" && echo ""
}

# Function used to purge binrepos from too big entries.
binrepo_purge() {
	local index=${1}

	[[ -z ${stages[${index},binrepo]} ]] && return
	local pkgcache_dir=$(repo_local_path ${stages[${index},binrepo]})/${stages[${index},binrepo_path]}
	local size_limit=${stages[${index},binrepo_fslimit]}
	[[ -z ${size_limit} ]] && return # No limit specified
	size_limit=$((size_limit * 1024 * 1024)) # Convert to B

	# Process metadata file
	local pkgcache_metadata=${pkgcache_dir}/Packages
	[[ -f ${pkgcache_metadata} ]] || return
	local packages_count=$(grep -oP '^PACKAGES: \K[0-9]+' ${pkgcache_metadata})
	local var_metadata_new=""
	local entry=""
	local entry_delete
	local metadata_modified
	while IFS= read -r LINE || [[ -n ${LINE} ]]; do
		if [[ -z ${LINE} ]]; then
			local entry_package=$(awk -F'/' '{print $1"/"$2}' <<< ${entry_path})
			local entry_version=${entry_cpv#$entry_package-}
			local entry_package_versioned=${entry_package}-${entry_version}
			if [[ -n ${entry_cpv} ]] && [[ ${entry_size} -gt ${size_limit} ]]; then
				entry_delete=true
			fi
			if [[ -n ${entry_delete} ]]; then
				echo "Purging ${entry_cpv}"
				((packages_count--)) || packages_count=0
				metadata_modified=true
				rm -f "${pkgcache_dir}/${entry_path}"
			else
				var_metadata_new+="${entry}\n"
			fi
			entry=""; entry_cpv=""; entry_path=""; entry_size=0; unset entry_delete
		else
			entry+="${LINE}\n"
			local key=${LINE%% *}
			if [[ ${key} == "CPV:" ]]; then
				entry_cpv=${LINE#* }
			elif [[ ${key} == "PATH:" ]]; then
				entry_path=${LINE#* }
			elif [[ ${key} == "SIZE:" ]]; then
				entry_size=${LINE#* }
			fi
		fi
	done < ${pkgcache_metadata}

	# Save changes
	if [[ ${metadata_modified} = true ]]; then
		echo -e "${var_metadata_new}" > "${pkgcache_metadata}"
		sed -i "s/^PACKAGES: .*/PACKAGES: $packages_count/" "${pkgcache_metadata}"
	fi
}

# Mark files that are too big as GIT-LFS (in given relrepo's subpath)
relrepo_mark_lfs() {
	local index=${1}
	local dir_to_check=${2}
	[[ -n ${stages[${index},relrepo]} ]] || continue # Ignore remote download jobs (or other jobs without relrepo)
	local size_limit=${stages[${index},relrepo_fslimit]} # in MB
	[[ -z ${size_limit} ]] && return # No limit specified

	local relrepo_local_path=$(repo_local_path ${stages[${index},relrepo]})
	local relrepo_kind=$(repo_kind ${stages[${index},relrepo]})
	local relrepo_url=$(repo_url ${stages[${index},relrepo]})

	pushd ${relrepo_local_path} > /dev/null
	local relrepo_full_path=${relrepo_local_path}/${dir_to_check}
	case ${relrepo_kind} in
		git)
			git lfs install > /dev/null # Install GIT LFS if not setup already
			local files=$(find ${relrepo_full_path} -type f -size +${size_limit}M -printf '%P\n')
			for file in ${files}; do
				git-lfs track ${file}
				git add .gitattributes > /dev/null
			done
			;;
	esac
	popd > /dev/null
}

# Build stages.
build_stages() {
	echo_color ${color_turquoise_bold} "[ Building stages ]"
	local i; for (( i=0; i<${stages_count}; i++ )); do
		[[ ${stages[${i},rebuild]} = false ]] && continue

		local stage_path_work=${work_path}/${stages[${i},platform]}/${stages[${i},release]}/${stages[${i},stage]}
		local build_completed=false

		if [[ ${stages[${i},kind]} = build ]]; then
			echo -e "${color_turquoise}Building stage: ${color_turquoise}${stages[${i},platform]}/${stages[${i},release]}/${stages[${i},stage]}${color_nc}"

			# Setup used paths:
			local stage_info_path_work=${stage_path_work}/stage.spec
			local catalyst_conf_work=${stage_path_work}/catalyst.conf

			local args="-af ${stage_info_path_work}"
			[[ -f ${catalyst_conf_work} ]] && args="${args} -c ${catalyst_conf_work}"

			# Perform build
			{
				catalyst $args && catalyst --purgetmponly -f ${stage_info_path_work} && # Clean tmp after build
				build_completed=true &&
				builds_status[${i}]=success &&
				echo -e "${color_green}Stage build completed: ${color_turquoise}${stages[${i},platform]}/${stages[${i},release]}/${stages[${i},stage]}${color_nc}" && echo ""
			} || {
				echo_color ${color_orange_bold} "Warning! Stage /${stages[${i},platform]}/${stages[${i},release]}/${stages[${i},stage]} failed. Disabling branch." &&
				builds_status[${i}]=failure &&
				disable_branch ${i}
			}


		elif [[ ${stages[${i},kind]} = download ]]; then
			echo -e "${color_turquoise}Downloading stage: ${color_yellow}${stages[${i},platform]}/${stages[${i},release]}/${stages[${i},stage]}${color_nc}"

			# Setup used paths:
			local download_script_path_work=${stage_path_work}/download.sh

			# Perform build
			{
				${download_script_path_work} &&
				build_completed=true &&
				builds_status[${i}]=success &&
				echo -e "${color_green}Stage download completed: ${color_yellow}${stages[${i},platform]}/${stages[${i},release]}/${stages[${i},stage]}${color_nc}" && echo ""
			} || {
				echo_color ${color_orange_bold} "Warning! Stage /${stages[${i},platform]}/${stages[${i},release]}/${stages[${i},stage]} failed. Disabling branch." &&
				builds_status[${i}]=failure &&
				disable_branch ${i}
			}

		elif [[ ${stages[${i},kind]} = binhost ]]; then
			echo -e "${color_turquoise}Building packages in stage: ${color_purple}${stages[${i},platform]}/${stages[${i},release]}/${stages[${i},stage]}${color_nc}"

			# Setup used paths:
			local binhost_script_path_work=${stage_path_work}/build-binpkgs.sh

			# Perform build
			{
				${binhost_script_path_work} &&
				build_completed=true &&
				builds_status[${i}]=success &&
				echo -e "${color_green}Stage build completed: ${color_purple}${stages[${i},platform]}/${stages[${i},release]}/${stages[${i},stage]}${color_nc}" && echo ""
			} || {
				echo_color ${color_orange_bold} "Warning! Stage /${stages[${i},platform]}/${stages[${i},release]}/${stages[${i},stage]} failed. Disabling branch." &&
				builds_status[${i}]=failure &&
				disable_branch ${i}
			}
		fi

		[[ ${build_completed} = true ]] && move_relrepos ${i}
		[[ ${build_completed} = true ]] && [[ ${UPLOAD_RELREPOS} = true ]] && upload_relrepos ${i}
		[[ ${build_completed} = true ]] && [[ ${UPLOAD_BINREPOS} = true ]] && upload_binrepos ${i}

	done

	echo_color ${color_green} "Stage builds completed" && echo ""
}

upload_binrepos() {
	local index=${1} # If no index, all repos are uploaded.

	[[ -z ${index} ]] && echo_color ${color_turquoise_bold} "[ Uploading binrepos ]"
	local handled_repos=()
	local i; for (( i=0; i<${stages_count}; i++ )); do
		[[ -z ${index} ]] || [[ ${index} = ${i} ]] || continue # Filter index if provided
		[[ ${stages[${i},selected]} = true ]] || ( [[ ${stages[${i},rebuild]} = true ]] && [[ ${BUILD} = true ]] ) || continue # Only upload selected repos or rebild if building now
		[[ -n ${stages[${i},binrepo]} ]] || continue # Ignore remote download jobs (or other jobs without binrepo)
		local binrepo_full_path=$(repo_local_path ${stages[${i},binrepo]})/${stages[${i},binrepo_path]}
		contains_string handled_repos[@] ${binrepo_full_path} && continue
		handled_repos+=(${binrepo_full_path})
		local binrepo_kind=$(repo_kind ${stages[${i},binrepo]})
		local binrepo_local_path=$(repo_local_path ${stages[${i},binrepo]})
		local binrepo_url=$(repo_url ${stages[${i},binrepo]})

		echo -e "${color_turquoise}Uploading binrepo: ${color_yellow}${binrepo_url}/${stages[${i},binrepo_path]}${color_nc}"
		binrepo_purge ${i}

		case ${binrepo_kind} in
		git)
			[[ -d ${binrepo_local_path}/.git ]] || continue # Skip if this repo doesnt yet exists

			# Check if there are changes to commit
			if [[ -n $(git -C ${binrepo_local_path} status --porcelain ${binrepo_full_path}) ]]; then
				git -C ${binrepo_local_path} add ${binrepo_full_path}
				git -C ${binrepo_local_path} commit -m "Automatic update: ${timestamp}" --only ${binrepo_full_path}
				# Check for write access.
				if repo_url=$(git -C ${binrepo_local_path} config --get remote.origin.url) && [[ ! ${repo_url} =~ ^https:// ]] && git -C ${binrepo_local_path} ls-remote &>/dev/null && git -C ${binrepo_local_path} push --dry-run &>/dev/null; then
					git -C ${binrepo_local_path} push
				else
					echo -e "${color_orange}Warning! No write access to binrepo: ${color_yellow}${binrepo_url}${color_nc}"
				fi
			else
				echo "No local changes detected"
			fi
			echo ""
			;;
		rsync)
			rsync ${RSYNC_OPTIONS} ${binrepo_full_path}/ ${ssh_username}@${binrepo_url}/${stages[${i},binrepo_path]}/
			echo ""
			;;
		esac

	done
	echo ""
}

# Move release files to relrepos.
declare -A relrepo_changed_directories=()
declare -A relrepo_latest_metadata_files=()
move_relrepos() {
	local index=${1} # If no index, all repos are uploaded.

	[[ -z ${index} ]] && echo_color ${color_turquoise_bold} "[ Collecting latest releases ]"
	local i; for (( i=0; i<${stages_count}; i++ )); do
		[[ -z ${index} ]] || [[ ${index} = ${i} ]] || continue # Filter index if provided
		[[ ${stages[${i},selected]} = true ]] || [[ ${stages[${i},rebuild]} = true ]] && [[ ${BUILD} = true ]] || continue # Only upload selected repos or rebild if building now
		[[ ${stages[${i},kind]} = build ]] || continue
		[[ -n ${stages[${i},relrepo]} ]] || continue # Ignore remote download jobs (or other jobs without relrepo)
		local relrepo_local_path=$(repo_local_path ${stages[${i},relrepo]})
		local relrepo_path=${stages[${i},relrepo_path]}
		# Determine if using new build or existing
		{ [[ ${stages[${i},rebuild]} = true ]] && [[ ${BUILD} = true ]] } && local used_product=${stages[${i},product]} || local used_product=${stages[${i},latest_build]}
		{ [[ ${stages[${i},rebuild]} = true ]] && [[ ${BUILD} = true ]] } && local used_timestamp=${stages[${i},timestamp_generated]} || local used_timestamp=${stages[${i},timestamp_latest]}
		if [[ -n ${used_product} ]] && [[ -n ${used_timestamp} ]]; then # Skip if no timestamp determined to upload
			local relrepo_subpath=$(echo ${relrepo_path} | sed "s|@TIMESTAMP@|${used_timestamp}|")
			local relrepo_full_path=${relrepo_local_path}/${relrepo_subpath}
			local include=false
			for file in ${catalyst_builds_path}/${used_product}*; do
				local fname=$(basename ${file})
				local dest=${relrepo_full_path}/${fname}
				if [[ ! -f ${dest} ]] && [[ -f ${file} ]]; then
					include=true
					echo "Moving ${fname} to releases repository"
					# Move file and link back to catalyst
					mkdir -p ${relrepo_full_path}
					mv ${catalyst_builds_path}/${stages[${i},rel_type]}/${fname} ${dest} || exit 1
					ln -s ${dest} ${catalyst_builds_path}/${stages[${i},rel_type]}/${fname} || exit 1
				fi
			done
			update_latest_release ${i} ${stages[${i},product_format]} ${used_timestamp} tar.xz
			[[ ${include} = true ]] && relrepo_changed_directories[${i}]="${relrepo_changed_directories[${i}]} ${relrepo_subpath}"
		fi
		{ [[ ${stages[${i},rebuild]} = true ]] && [[ ${BUILD} = true ]] } && local used_product_iso=${stages[${i},product_iso]} || local used_product_iso=${stages[${i},latest_iso]}
		{ [[ ${stages[${i},rebuild]} = true ]] && [[ ${BUILD} = true ]] } && local used_timestamp_iso=${stages[${i},timestamp_generated]} || local used_timestamp_iso=${stages[${i},timestamp_iso_latest]}
		if [[ -n ${used_product_iso} ]] && [[ -n ${used_timestamp_iso} ]]; then # Skip if no timestamp determined to upload
			local relrepo_subpath=$(echo ${relrepo_path} | sed "s|@TIMESTAMP@|${used_timestamp_iso}|")
			local relrepo_full_path=${relrepo_local_path}/${relrepo_subpath}
			local include=false
			for file in ${catalyst_builds_path}/${used_product_iso}*; do
				local fname=$(basename ${file})
				local dest=${relrepo_full_path}/${fname}
				if [[ ! -f ${dest} ]] && [[ -f ${file} ]]; then
					include=true
					echo "Moving ${fname} to releases repository"
					# Move file and link back to catalyst
					mkdir -p ${relrepo_full_path}
					mv ${catalyst_builds_path}/${stages[${i},rel_type]}/${fname} ${dest} || exit 1
					ln -s ${dest} ${catalyst_builds_path}/${stages[${i},rel_type]}/${fname} || exit 1
				fi
			done
			update_latest_release ${i} ${stages[${i},product_iso_format]} ${used_timestamp_iso} iso
			[[ ${include} = true ]] && relrepo_changed_directories[${i}]="${relrepo_changed_directories[${i}]} ${relrepo_subpath}"
		fi
	done
	echo ""
}

# Update latest-release.txt file for given stage and timestamp
update_latest_release() {
	local index=${1}
	local used_product_format=${2}
	local used_timestamp=${3}
	local extension=${4}
	local relrepo_local_path=$(repo_local_path ${stages[${index},relrepo]})
	local relrepo_path=$(echo ${stages[${index},relrepo_path]} | sed "s/@TIMESTAMP@/${used_timestamp}/g")
	local relrepo_path_metadata=$(echo ${stages[${index},relrepo_path_metadata]} | sed "s/@TIMESTAMP@/${used_timestamp}/g")
	local product_filename=$(basename $(echo ${used_product_format} | sed "s/@TIMESTAMP@/${used_timestamp}/g")).${extension}
	local metadata_filename=latest-$(basename $(echo ${used_product_format//@TIMESTAMP@/} | sed 's/^-//;s/-$//')).txt
	local product_path=${relrepo_local_path}/${relrepo_path}/${product_filename}
	local metadata_path=${relrepo_local_path}/${relrepo_path_metadata}/${metadata_filename}
	local product_relative_path=$(realpath --relative-to="${relrepo_local_path}/${relrepo_path_metadata}" "${relrepo_local_path}/${relrepo_path}")/${product_filename}
	local product_size=$(stat --format="%s" ${product_path})
	local release_name=${stages[${i},platform]}/${stages[${i},release]}/${stages[${i},stage]}
	echo "Marking latest release of ${release_name} [${used_product_format}] as ${used_timestamp}"
	echo "${product_relative_path} ${product_size}" > ${metadata_path}
	relrepo_latest_metadata_files[${index}]+="${relrepo_latest_metadata_files[${index}]} ${metadata_path}"
}

# Upload releases to release repos.
upload_relrepos() {
	local index=${1}

	[[ -z ${index} ]] && echo_color ${color_turquoise_bold} "[ Uploading releases ]"
	local i; for (( i=0; i<${stages_count}; i++ )); do
		[[ -z ${index} ]] || [[ ${index} = ${i} ]] || continue # Filter index if provided
		local relrepo_local_path=$(repo_local_path ${stages[${i},relrepo]})
		local relrepo_kind=$(repo_kind ${stages[${i},relrepo]})
		local relrepo_url=$(repo_url ${stages[${i},relrepo]})
		local relrepo_new_directories=$(echo "${relrepo_changed_directories[${i}]}" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
		local relrepo_new_metadata_files=$(echo "${relrepo_latest_metadata_files[$i]}" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
		local relrepo_attributes_path=${relrepo_local_path}/.gitattributes
		relrepo_changed_directories[${i}]=""
		relrepo_latest_metadata_files[${i}]=""
		[[ -z ${relrepo_new_directories} ]] && [[ -z ${relrepo_new_metadata_files} ]] && continue # Nothing new to upload

		echo -e "${color_turquoise}Uploading release: ${color_yellow}${relrepo_url}/${dir}${color_nc}"

		local git_upload=false

		# Add release files
		for dir in ${relrepo_new_directories}; do
			local relrepo_full_path=${relrepo_local_path}/${dir}
			case ${relrepo_kind} in
			git)
				[[ -d ${relrepo_local_path}/.git ]] || continue # Skip if this repo doesnt yet exists
				relrepo_mark_lfs ${i} ${dir}

				# Check if there are changes to commit
				if [[ -n $(git -C ${relrepo_local_path} status --porcelain ${relrepo_full_path}) ]]; then
					git -C ${relrepo_local_path} add ${relrepo_full_path}
					[[ -f ${relrepo_attributes_path} ]] && git -C ${relrepo_local_path} add ${relrepo_attributes_path}
					git_upload=true
				fi
				;;
			rsync)
				rsync ${RSYNC_OPTIONS} ${relrepo_full_path}/ ${ssh_username}@${relrepo_url}/${dir}/
				;;
			esac
		done

		# Add metadata files
		for file in ${relrepo_new_metadata_files}; do
			case ${relrepo_kind} in
			git)
				[[ -d ${relrepo_local_path}/.git ]] || continue # Skip if this repo doesnt yet exists

				# Check if there are changes to commit
				if [[ -n $(git -C ${relrepo_local_path} status --porcelain ${file}) ]]; then
					git -C ${relrepo_local_path} add ${file}
					git_upload=true
				fi
				;;
			rsync)
				# TODO: Upload rsync metadata file only here
				rsync ${RSYNC_OPTIONS} ${relrepo_full_path}/ ${ssh_username}@${relrepo_url}/${dir}/
				;;
			esac
		done

		if [[ ${git_upload} = true ]]; then
			git -C ${relrepo_local_path} commit -m "Automatic update: ${timestamp}" # --only ${relrepo_full_path} # Note: Cannot use --only when dealing with .gitattribues in separate directory
			# Check for write access.
			if repo_url=$(git -C ${relrepo_local_path} config --get remote.origin.url) && [[ ! ${repo_url} =~ ^https:// ]] && git -C ${relrepo_local_path} ls-remote &>/dev/null && git -C ${relrepo_local_path} push --dry-run &>/dev/null; then
				git -C ${relrepo_local_path} push
			else
				echo -e "${color_orange}Warning! No write access to release repo: ${color_yellow}${relrepo_url}${color_nc}"
			fi
		fi

	done
	echo ""
}

# ------------------------------------------------------------------------------
# Helper functions:

echo_color() { # Usage: echo_color COLOR MESSAGE
	echo -e "${1}${2}${color_nc}"
}

contains_string() {
	local array=("${!1}")
	local search_string="$2"
	local found=0

	for element in "${array[@]}"; do
		if [[ "$element" == "$search_string" ]]; then
			found=1
			break
		fi
	done

	if [[ $found -eq 1 ]]; then
		return 0  # true
	else
		return 1  # false
	fi
}

# Get list of directories in given directory.
get_directories() {
	local path=${1}
	local directories=($(find ${path}/ -mindepth 1 -maxdepth 1 \( -type d -o -type l -xtype d \) -exec basename {} \; | sort))
	echo ${directories[@]}
}

basearch_to_baseraw() {
	local basearch=${1}
	for key in ${!ARCH_MAPPINGS[@]}; do
		if [[ ${ARCH_MAPPINGS[${key}]} == ${basearch} ]]; then
			echo ${key}
			return
		fi
	done
	echo ${basearch}
}

# Return value of given property from given spec file.
read_spec_variable() {
	local spec_path=${1}
	local variable_name=${2}
	# get variable from spec file and trim whitespaces.
	local value=$(cat ${spec_path} | sed -n "/^${variable_name}:/s/^${variable_name}:\(.*\)/\1/p" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
	echo ${value}
}

# Update value in given spec or add if it's not present there
set_spec_variable() {
	local spec_path=${1}
	local key=${2}
	local new_value="${3}"

	if grep -q "^$key:" ${spec_path}; then
		sed -i "/^$key:/,/^[^:]*:/ {
			/^$key:/ s|^$key:.*|$key: $new_value|
			/^[^:]*:/!d
		}" ${spec_path}
	else
		echo "${key}: $new_value" >> ${spec_path}
	fi
}

# Set variable in spec only if it's not specified yet.
# Use this for example for treeish - you can sepcify selected one or leave it out to get automatic value.
set_spec_variable_if_missing() {
	local spec_path=${1}
	local key=${2}
	local new_value="${3}"
	if ! grep -q "^$key:" "${spec_path}"; then
		echo "$key: $new_value" >> "${spec_path}"
	fi
}

# Fill tmp data in spec (@TIMESTAMP@, etc)
update_spec_variable() {
	local spec_path=${1}
	local key=${2}
	local new_value="${3}"
	sed -i "s|@${key}@|${new_value}|g" ${spec_path}
}

# Replace variables in given stage variable, by replacing some strings with calculated end results - timestamp, PLATFORM, STAGE.
sanitize_spec_variable() {
	local platform="$1"
	local release="$2"
	local stage="$3"
	local family="$4"
	local base_arch="$5"
	local sub_arch="$6"
	local rel_type="$7"
	local value="$8"
	echo "${value}" | sed "s|@RELEASE@|${release}|g" | sed "s|@PLATFORM@|${platform}|g" | sed "s|@STAGE@|${stage}|g" | sed "s|@BASE_ARCH@|${base_arch}|g" | sed "s|@SUB_ARCH@|${sub_arch}|g" | sed "s|@FAMILY_ARCH@|${family}|g" | sed "s|@REL_TYPE@|${rel_type}|g"
}

# Scans local and binhost targets and updates their parent property in stages array.
update_parent_indexes() {
	local i; for (( i=0; i<${stages_count}; i++ )); do
		# Search for parents only for supported stages
                if [[ ${stages[${i},kind]} != build ]] && [[ ${stages[${i},kind]} != binhost ]]; then
                        continue
                fi
		stages[${i},parent]=$(find_stage_producing ${stages[${i},source_subpath]})
	done
}

# Searches for index of a parent stage, that produces given product. Can be used to match with source_subpath
find_stage_producing() {
	local searched_product=${1}
	local j; for (( j=0; j<${stages_count}; j++ )); do
		if [[ ${searched_product} == ${stages[${j},product]} ]]; then
			echo ${j}
			return
		fi
	done
}

# Prepare array that describes the order of stages based on inheritance.
# Store information if stage has local parents.
# This is function uses requrency to process all required parents before selected stage is processed.
insert_stage_with_inheritance() { # arg - index, required_by_id
	local index=${1}
	local dependency_stack=${2:-'|'}
	if ! contains_string stages_order[@] ${index}; then
		# If you can find a parent that produces target = this.source, add this parent first. After that add this stage.
		local parent_index=${stages[${index},parent]}
		if [[ -n ${parent_index} ]]; then

			# Check for cicrular dependencies
			if [[ ${dependency_stack} == *"|${parent_index}|"* ]]; then
				dependency_stack="${dependency_stack}${index}|"
				echo "Circular dependency detected for ${parent_platform}/${parent_release}/${parent_stage}. Verify your templates."
				IFS='|' read -r -a dependency_indexes <<< "${dependency_stack#|}"
				echo "Stack:"
				local found_parent=false
				for i in ${dependency_indexes[@]}; do
					if [[ ${found_parent} = false ]] && [[ ${parent_index} != ${i} ]]; then
						continue
					fi
					found_parent=true
					echo ${stages[${i},platform]}/${stages[${i},release]}/${stages[${i},stage]}
				done
				exit 1
			fi

			# Insert parent before current index
			local next_dependency_stack="${dependency_stack}${index}|"
			insert_stage_with_inheritance ${parent_index} "${next_dependency_stack}"
		fi
		stages_order+=(${index})
	fi
}

draw_stages_tree() {
	local index=${1}
	local prefix=${2}

	if [[ -z ${index} ]]; then
		# Get indexes of root elements.
		local child_array=()
		local i; for (( i=0; i < ${stages_count}; i++ )); do
			if [[ ${stages[${i},takes_part]} = true ]] && [[ -z ${stages[${i},parent]} ]]; then
				child_array+=(${i})
			fi
		done
	else
		# Only include branches that takes part in the process
		local child_array_tmp=(${stages[${index},children]}) # Map to array if starting from string
		local child_array=()
		for child in ${child_array_tmp[@]}; do
			if [[ ${stages[${child},takes_part]} = true ]]; then
				child_array+=(${child})
			fi
		done
	fi

	local i=0; for child in ${child_array[@]}; do
		((i++))
		if [[ ${stages[${child},kind]} = build ]]; then
			local color=${color_turquoise}
			local color_bold=${color_turquoise_bold}
		elif [[ ${stages[${child},kind]} = download ]]; then
			local color=${color_yellow}
			local color_bold=${color_yellow_bold}
		elif [[ ${stages[${child},kind]} = binhost ]]; then
			local color=${color_purple}
			local color_bold=${color_purple_bold}
		fi

		local display_name=${stages[${child},platform]}/${stages[${child},release]}/${stages[${child},stage]}
		local stage_name=${color_gray}${display_name}${color_nc}
		# If stage is not being rebuild and it has direct children that are being rebuild, display used latest_build.
		if [[ ${stages[${child},rebuild]} == false ]] && [[ -n ${stages[${child},timestamp_latest]} ]]; then
			for c in ${stages[${child},children]}; do
				if [[ ${stages[${c},rebuild]} = true ]]; then
					display_name="${display_name} (${stages[${child},timestamp_latest]})"
					stage_name=${color_gray}${display_name}${color_nc}
					break
				fi
			done
		fi
		if [[ ${stages[${child},rebuild]} = true ]]; then
			stage_name=${stages[${child},platform]}/${stages[${child},release]}/${color}${stages[${child},stage]}${color_nc}
		fi
		if [[ ${stages[${child},selected]} = true ]]; then
			stage_name=${stages[${child},platform]}/${stages[${child},release]}/${color_bold}${stages[${child},stage]}${color_nc}
		fi


		new_prefix="${prefix} "
		if [[ -n ${stages[${child},children]} ]]; then
			new_prefix="${prefix}   "
		fi
		if [[ ${i} == ${#child_array[@]} ]]; then
			new_prefix="${prefix}    "
			echo -e "${prefix} ${stage_name}${color_nc}"
		else
			echo -e "${prefix} ${stage_name}${color_nc}"
		fi
		draw_stages_tree ${child} "${new_prefix}"
	done
}

# Was given stage selected by user arguments (or true if not provided.)
is_stage_selected() {
	local platform=${1}
	local release=${2}
	local stage=${3}
	if [[ ${#selected_stages_templates[@]} -eq 0 ]]; then
		echo true
		return
	fi

	set -f
	for pattern in ${selected_stages_templates[@]}; do
		IFS='/' read -r exp_platform exp_release exp_stage <<< ${pattern}
		unset fits_stage; unset fits_release; unset fits_platform
		if [[ -z ${exp_stage} ]] || [[ ${stage} == ${exp_stage} ]]; then
			local fits_stage=true
		fi
		if { [[ -z ${exp_stage} ]] && [[ -z ${exp_release} ]] } || [[ ${release} == ${exp_release} ]]; then
			local fits_release=true
		fi
		if { [[ -z ${exp_stage} ]] && [[ -z ${exp_release} ]] && [[ -z ${exp_platform} ]] } || [[ ${platform} == ${exp_platform} ]]; then
			local fits_platform=true
		fi
		local should_include=$([[ ${fits_platform} == true && ${fits_release} == true && ${fits_stage} == true ]] && echo true || echo false)
		if [[ ${should_include} = true ]]; then
			echo true
			set +f
			return
		fi
	done
	set +f

	echo false
}

print_debug_stack() {
	# Debug mode
	echo_color ${color_turquoise_bold} "[ Stages details ]"
	for ((i=0; i<${stages_count}; i++)); do
		[[ ${stages[${i},takes_part]} = false ]] && echo -ne "${color_gray}\r"
		echo "Stage details at index ${i}:"
		for key in ${STAGE_KEYS[@]}; do
			printf "%-22s%s\n" "${key}:" "${stages[$i,$key]}"
		done
		echo "--------------------------------------------------------------------------------"
		echo -ne "${color_nc}\r"
	done
}

# Either is rebuild itself or is a part of rebuild process of it's children.
is_taking_part_in_rebuild() {
	local index=${1}
	if [[ ${stages[${index},rebuild]} = true ]]; then
		echo true
		return
	elif [[ -n ${stages[${index},children]} ]]; then
		for child in ${stages[${index},children]}; do
			if [[ $(is_taking_part_in_rebuild ${child}) = true ]]; then
				echo true
				return
			fi
		done
	fi
	echo false
}

repo_kind() {
	local repo=${1}
	# local, git, rsync
	local repo_kind=$(echo ${repo} | grep -oP '(?<=^\[)[^]]+(?=\])')
	if [[ -z ${repo_kind} ]] && { [[ ${repo} == http://* || ${repo} == https://* || ${repo} == git@* ]] }; then
		# Assume git repo for URLs
		repo_kind=git
	fi
	# If type not determined yet, assume local.
	[[ -z ${repo_kind} ]] && repo_kind=local
	echo ${repo_kind}
}

# Maps repo location to local path.
# For remote addresses it maps it to local path in /var/cache.
# For local addressed it returns the same path without changes.
repo_local_path() {
	local repository=${1}
	local repo_kind=$(repo_kind ${repository})
	local repo_url=$(repo_url ${repository})

	case ${repo_kind} in
	git|rsync)
		local local_name=$(echo ${repo_url} | sed 's|http[s]*://||' | sed 's|^git@||' | sed -e 's/[^A-Za-z0-9._-]/_/g')
		echo ${repos_cache_path}/${repo_kind}_${local_name}
		;;
	local)
		echo ${repository}
		;;
	*)	# Unsupported type of repository, just return it's full value.
		echo ${repository}
		;;
	esac
}

# Removes [KIND] from repo url or local path.
repo_url() {
	local repository=${1}
	echo ${repository} | sed 's/^\[[^]]*\]//'
}

# Finds and loads catalyst toml file for specified basearch.subarch
declare -A TOML_CACHE=()
load_toml() {
	local basearch=${1}
	local subarch=${2}
	if [[ -n ${TOML_CACHE[${basearch},${subarch},chost]} ]]; then
		return # Already loaded
	fi
	local toml_file=$(grep -rl ${basearch}.${subarch} ${catalyst_usr_path}/arch)
	unset toml_chost toml_common_flags toml_use
	[[ -f ${toml_file} ]] || return
	mapfile -t use < <(tomlq -r ".${basearch}.${subarch}.USE // empty | .[]" ${toml_file})
	mapfile -t common_flags < <(tomlq ".${basearch}.${subarch}.COMMON_FLAGS // empty" ${toml_file} | sed 's/"//g')
	mapfile -t chost < <(tomlq ".${basearch}.${subarch}.CHOST // empty" ${toml_file} | sed 's/"//g')
	TOML_CACHE[${basearch},${subarch},chost]="${chost}"
	TOML_CACHE[${basearch},${subarch},common_flags]="${common_flags}"
	TOML_CACHE[${basearch},${subarch},use]="${use[*]:-""}"
}

# Validates if given sanity checks are passed
validate_sanity_checks() {
	local is_optional=${1}
	local print_success="${2}"
	local checks="${3}"
	local pass=true
	local comments=""
	for check in ${checks}; do
		if [[ ${!check} = true ]]; then
			if [[ ${print_success} = true ]]; then
				comments+="[${color_green}+${color_nc}] ${color_green}${check}${color_nc}\n"
			fi
		elif [[ ${is_optional} = true ]]; then
			comments+="[${color_orange}-${color_nc}] ${color_orange}${check}${color_nc}\n"
		else
			comments+="[${color_red}-${color_nc}] ${color_red}${check}${color_nc}\n"
			pass=false
		fi
	done
	[[ -n ${comments} ]] && comments=${comments::-2} # Remove last new line
	if [[ ! ${pass} = true ]]; then
		echo "Required sanity checks failed:"
		echo -e ${comments}
		echo "Please install and configure required tools first."
		echo "Exiting."
		exit 1
	elif [[ -n ${comments} ]]; then
		echo -e ${comments}
	fi
}

# Get profile from first parent that has it definied.
# If no parent definies profile yet, assume default/linux/@BASE_ARCH@/23.0.
inherit_profile() {
	local index=${1}
	local parent_index=${stages[${index},parent]}
	if [[ -z ${parent_index} ]]; then
		echo "default/linux/@BASE_ARCH@/23.0"
		return
	fi
	local parent_profile=${stages[${parent_index},profile]}
	if [[ -n ${parent_profile} ]]; then
		echo ${parent_profile}
	else
		inherit_profile ${parent_index}
	fi
}

# Marks selected stage and all it's children branch as rebuild=false.
disable_branch() {
	local index=${1}
	local children="${stages[${index},children]}"
	echo_color ${color_orange} "Disable: ${stages[${index},platform]}/${stages[${index},release]}/${stages[${index},stage]}"
	stages[${index},rebuild]=false
	[[ -z ${builds_status[${index}]} ]] && builds_status[${index}]=disabled
	for child in ${children}; do
		disable_branch ${child}
	done
}

# Remove old files from previous builds.
purge_old_builds_and_isos() {
	echo_color ${color_turquoise_bold} "[ Purge old builds ]"
	local available_builds_files=$(find ${catalyst_builds_path} \( -type f -o -type l \) \( -name "*.tar.xz" -o -name "*.iso" \) -printf '%P\n')
	local to_remove=()
	local to_remove_in_relrepo=()
#	relrepo_changed_directories=() # Empty at this step, as it will be performed after previous changes were already uploaded.
	for ((i=0; i<${stages_count}; i++)); do
		[[ ! ${stages[${i},selected]} = true ]] && continue
		# Collect files from catalyst
		local _available_builds=($(printf "%s\n" "${available_builds_files[@]}" | grep -E $(echo ${stages[${i},product_format]} | sed 's/@TIMESTAMP@/[0-9]{8}T[0-9]{6}Z/g') | sort)) # Sorted from oldest
		local _available_isos=($([[ -n "${stages[${i},product_iso_format]}" ]] && printf "%s\n" "${available_builds_files[@]}" | grep -E $(echo ${stages[${i},product_iso_format]} | sed 's/@TIMESTAMP@/[0-9]{8}T[0-9]{6}Z/g') | sort))
		for ((j=0; j<((${#_available_builds[*]}-1)); j++)); do
			# Double check to make sure currently built product is not the same file
			[[ ${_available_builds[${j}]} == ${stages[${i},product]}* ]] && continue
			to_remove+=(${_available_builds[${j}]})
		done
		for ((j=0; j<((${#_available_isos[*]}-1)); j++)); do
			# Double check to make sure currently built iso is not the same file
			[[ ${_available_isos[${j}]} == ${stages[${i},product_iso]}* ]] && continue
			to_remove+=(${_available_isos[${j}]})
		done
		# Collect files from relrepo that are not in catalyst
		local relrepo_path=$(repo_local_path ${stages[${i},relrepo]})
		if [[ -n ${relrepo_path} ]]; then
			local available_builds_files_in_relrepo=$(find ${relrepo_path} -type f \( -name "*.tar.xz" -o -name "*.iso" \) -printf '%P\n')
			local product_in_relrepo=$(echo ${stages[${i},relrepo_path]}/$(basename ${stages[${i},product]}) | sed 's/@TIMESTAMP@/${stages[${i},timestamp_generated]}/g') # Format of release in relrepo (including subpath and timestamp folder
			local product_iso_in_relrepo=$([[ -n ${stages[${i},product_iso_format]} ]] && echo ${stages[${i},relrepo_path]}/$(basename ${stages[${i},product_iso]}) | sed 's/@TIMESTAMP@/${stages[${i},timestamp_generated]}/g')
			local product_format_in_relrepo=$(echo ${stages[${i},relrepo_path]}/$(basename ${stages[${i},product_format]}) | sed 's/@TIMESTAMP@/[0-9]{8}T[0-9]{6}Z/g') # Format of release in relrepo (including subpath and timestamp folder
			local product_iso_format_in_relrepo=$([[ -n ${stages[${i},product_iso_format]} ]] && echo ${stages[${i},relrepo_path]}/$(basename ${stages[${i},product_iso_format]}) | sed 's/@TIMESTAMP@/[0-9]{8}T[0-9]{6}Z/g')
			local _available_builds_in_relrepo=($(printf "%s\n" "${available_builds_files_in_relrepo[@]}" | grep -E ${product_format_in_relrepo} | sort)) # Sorted from oldest
			local _available_isos_in_relrepo=($([[ -n "${product_iso_format_in_relrepo}" ]] && printf "%s\n" "${available_builds_files_in_relrepo[@]}" | grep -E ${product_iso_format_in_relrepo} | sort))
			for ((j=0; j<((${#_available_builds_in_relrepo[*]}-1)); j++)); do
				# Double check to make sure currently built product is not the same file
				[[ ${_available_builds_in_relrepo[${j}]} == ${product_in_relrepo}* ]] && continue
				to_remove_in_relrepo+=(${relrepo_path}/${_available_builds_in_relrepo[${j}]})
				# Mark relrepo dir to upload changes
				local relrepo_subdir=$(dirname ${_available_builds_in_relrepo[${j}]})
				relrepo_changed_directories[${i}]="${relrepo_changed_directories[${i}]} ${relrepo_subdir}"
			done
			for ((j=0; j<((${#_available_isos_in_relrepo[*]}-1)); j++)); do
				# Double check to make sure currently built iso is not the same file
				[[ ${_available_isos_in_relrepo[${j}]} == ${product_iso_in_relrepo}* ]] && continue
				to_remove_in_relrepo+=(${relrepo_path}/${_available_isos_in_relrepo[${j}]})
				# Mark relrepo dir to upload changes
				local relrepo_subdir=$(dirname ${_available_isos_in_relrepo[${j}]})
				relrepo_changed_directories[${i}]="${relrepo_changed_directories[${i}]} ${relrepo_subdir}"
			done
		fi
	done
	if [[ -n ${to_remove} ]] || [[ -n ${to_remove_in_relrepo} ]]; then
		echo "Will remove old builds:"
		for file in ${to_remove[@]}; do
			echo -e " - ${color_gray}${file}${color_nc}"
		done
		for file in ${to_remove_in_relrepo[@]}; do
			echo -e " - ${color_gray}${file}${color_nc}"
		done
		echo "Use CTRL+C to cancel."
		echo "Removing in..."
		for i in {10..0}; do
			echo -ne "\r${i} "
			sleep 1
		done
		echo ""
		for file in ${to_remove[@]}; do
			echo -e "${color_red}Removing: ${color_gray}${catalyst_builds_path}/${color_nc}${file}${color_gray}*${color_nc}"
			for file in ${catalyst_builds_path}/${file}*; do
				# If it's a link, delete also source file
				if [[ -L ${file} ]]; then
					local target=$(readlink ${file})
					if [[ -f ${target} ]]; then
						rm -f ${target}
					fi
				fi
				rm -f ${file}
			done
		done
		for file in ${to_remove_in_relrepo[@]}; do
			echo -e "${color_red}Removing: ${color_gray}${color_nc}${file}${color_gray}*${color_nc}"
			for file in ${file}*; do
				[[ -f ${file} ]] && rm -f ${file}
			done
			# TODO: If release directory if left empty, remove this directory too
			# Warning. This could case issues with later rsync if the folder doesnt exists anymore.
			# Git should remove remote empty folders automatically.
		done
	else
		echo "No old builds to remove found."
	fi
	echo ""
}

# Display status of builds after finished.
report_status() {
	echo_color ${color_turquoise_bold} "[ Build report ]"

	local message=""
	local index; for (( index=0; index<${stages_count}; index++ )); do
		local status=${builds_status[${index}]}
		[[ -z ${status} ]] && [[ ${stages[${index},rebuild]} = true ]] && status=disabled # Mark not started jobs as disabled
		[[ -z ${status} ]] && continue

		if [[ ${stages[${index},kind]} = build ]]; then
			local color=${color_turquoise}
		elif [[ ${stages[${index},kind]} = download ]]; then
			local color=${color_yellow}
		elif [[ ${stages[${index},kind]} = binhost ]]; then
			local color=${color_purple}
		fi

		if [[ ${status} = success ]]; then
			local color_status=${color_green}
		elif [[ ${status} = failure ]]; then
			local color_status=${color_red}
		elif [[ ${status} = disabled ]]; then
			local color_status=${color_orange}
		else
			local color_status=${color_nc}
		fi

		local status_padded="[${color_status}$(printf "%-8s" "${status}")${color_nc}]"
		local display_name="${status_padded} ${stages[${index},platform]}/${stages[${index},release]}/${color}${stages[${index},stage]} ${color_nc}"
		[[ -n ${message} ]] && message="${message}\n${display_name}" || message="${display_name}"
	done
	echo -e "${message}"
	echo -e "${message}" > ${report_path}
	echo ""
}

# ------------------------------------------------------------------------------
# START:

# Initial config

# Check for root privilages.
if [[ $EUID -ne 0 ]]; then
	echo "This script must be run as root"
	exit 1
fi

declare PLATFORM_KEYS=( # Variables allowed in platform.conf
	arch      repos
	cpu_flags compression_mode
	binrepo binrepo_fslimit binrepo_path
	relrepo relrepo_fslimit relrepo_path relrepo_path_metadata
	use
)
declare RELEASE_KEYS=( # Variables allowed in release.conf
	repos
        common_flags chost
        cpu_flags compression_mode
	binrepo binrepo_fslimit binrepo_path
	relrepo relrepo_fslimit relrepo_path relrepo_path_metadata
	use
)
declare STAGE_KEYS=( # Variables stored in stages[] for the script.
	kind profile

	arch_basearch arch_baseraw     arch_subarch
	arch_family   arch_interpreter arch_emulation

	platform release stage
	rel_type target version_stamp releng_base

	chost common_flags cpu_flags

	source_subpath
	parent children
	product product_format
	product_iso product_iso_format
	latest_build latest_iso
	timestamp_latest timestamp_iso_latest timestamp_generated

	treeish
	repos
	binrepo binrepo_fslimit binrepo_path
	relrepo relrepo_fslimit relrepo_path relrepo_path_metadata
	catalyst_conf compression_mode
	packages use use_toml

	selected rebuild takes_part

	url
)
declare TARGET_KEYS=( # Values in spec files that can be specified as <TARGET>/<VALUE>. This array is used to add <TARGET>/ automatically to these values in templates.
	use             packages unmerge      rcadd    rcdel
	rm              empty    iso          volid    fstype
	gk_mainargs     type     fsscript     groups   root_overlay
	ssh_public_keys users    linuxrc      bootargs cdtar
	depclean        fsops    modblacklist motd     overlay
	readme          verify
)
declare -A TARGET_MAPPINGS=(
	# Used to fill spec fsscript and similar with correct key.
	[livecd-stage1]=livecd
	[livecd-stage2]=livecd
)
declare -A ARCH_MAPPINGS=(
	# Map from arch command to base arch. TODO: Add more mappings if needed.
	[aarch64]=arm64
	[x86_64]=amd64
)
declare -A ARCH_FAMILIES=(
	# Map from base arch to arch family. Add only if different than base arch.
	[ppc64]=ppc
)
declare -A ARCH_INTERPRETERS=(
	# Add custom interpreters if needed.
	# By default script will try to find interpreter by matching with basename->raw_basename (ie x86_64).
	# This can also be used if multiple interpreters are needed.
	# Keys should correspond to baseraw, for example x86_64, aarch64, ppc64
	[x86_64]="/usr/bin/qemu-x86_64 /usr/bin/qemu-i386"
)
declare -A RELENG_BASES=(
	# Definies base releng folder for current stage.
	# This is used to prepare portage_confdir correctly for every stage,
	# while the name of releng portage subfolder is filled automatically.
	[stage1]=stages [stage2]=stages [stage3]=stages [stage4]=stages
	[livecd-stage1]=isos [livecd-stage2]=isos
	[binhost]=stages
)
# List of targets that are compressed after build. This allows adding compression_mode property automatically to stages.
declare COMPRESSABLE_TARGETS=(stage1 stage2 stage3 stage4 livecd-stage1 livecd-stage2)

readonly RSYNC_OPTIONS="--archive --delete --delete-after --omit-dir-times --delay-updates --mkpath --stats"

readonly host_arch=${ARCH_MAPPINGS[$(arch)]:-$(arch)} # Mapped to release arch
readonly timestamp=$(date -u +"%Y%m%dT%H%M%SZ") # Current timestamp.

readonly color_gray='\033[0;90m'
readonly color_red='\033[0;31m'
readonly color_green='\033[0;32m'
readonly color_turquoise='\033[0;36m'
readonly color_turquoise_bold='\033[1;36m'
readonly color_yellow='\033[0;33m'
readonly color_yellow_bold='\033[1;33m'
readonly color_orange='\033[38;5;214m'
readonly color_orange_bold='\033[1;38;5;214m'
readonly color_purple='\033[38;5;135m'
readonly color_purple_bold='\033[1;38;5;135m'
readonly color_nc='\033[0m' # No Color

[[ ! -d /etc/catalyst-lab/templates ]] && mkdir -p /etc/catalyst-lab/templates
# Load/create config.
[[ ! -f /etc/catalyst-lab/catalyst-lab.conf ]] && echo_color ${color_red} "Configuration file missing: /etc/catalyst-lab/catalyst-lab.conf" && exit 1
source /etc/catalyst-lab/catalyst-lab.conf

# Constants:
readonly tmp_path=/tmp/catalyst-lab
readonly var_tmp_path=/var/tmp/catalyst-lab
readonly cache_path=/var/cache/catalyst-lab
readonly releng_path=/opt/releng
readonly seeds_url=https://gentoo.osuosl.org/releases/@ARCH_FAMILY@/autobuilds
readonly templates_path=/etc/catalyst-lab/templates
readonly repos_cache_path=${cache_path}/repos
readonly catalyst_path=/var/tmp/catalyst
readonly catalyst_builds_path=${catalyst_path}/builds
readonly catalyst_tmp_path=${catalyst_path}/tmp
readonly catalyst_usr_path=/usr/share/catalyst
readonly work_path=${tmp_path}/${timestamp}
readonly binhost_work_path=${var_tmp_path}/${timestamp}
readonly binrepo_purge_script_path=${work_path}/binrepo_purge.sh
readonly log_path=${work_path}/build.log
readonly report_path=${work_path}/report.log

# Create required folders if don't exists
if [[ ! -d ${catalyst_builds_path} ]]; then
	mkdir -p ${catalyst_builds_path}
fi

# Script arguments:
declare -a selected_stages_templates
while [ $# -gt 0 ]; do case ${1} in
	--update-snapshot) FETCH_FRESH_SNAPSHOT=true;; # Update portage snapshot.
	--update-releng) FETCH_FRESH_RELENG=true;;     # Update releng repository.
	--update-repos) FETCH_FRESH_REPOS=true;;       # Update remote repos for releases and binhosts.
	--upload-binrepos) UPLOAD_BINREPOS=true;;      # Upload changes in binrepos.
	--upload-releases) UPLOAD_RELREPOS=true;;      # Upload changes in releases.
	--purge) PURGE=true;;                          # Clean all builds and isos except the latest.
	--clean) CLEAN_BUILD=true;;                    # Don't use any existing sources even if available (Except for downloaded seeds).
	--build) BUILD=true; PREPARE=true;;            # Prepare is implicit when using --build.
	--prepare) PREPARE=true;;                      # Create build files.
	--debug) DEBUG=true;;                          # Display additional debug information.
	--*) echo "Unknown option ${1}"; exit;;
	-*) echo "Unknown option ${1}"; exit;;
	*) selected_stages_templates+=("${1}");;       # Add selected stages.
esac; shift; done

trap "echo ''; report_status" SIGINT

# Setup logging
[[ ${PREPARE} = true ]] && mkdir -p $(dirname ${log_path}) && exec > >(tee -a ${log_path}) 2>&1

# Main sanity check:
readonly qemu_is_installed=$( which qemu-img >/dev/null 2>&1 && echo true || echo false )
readonly qemu_has_static_user=$( ( $(ls /var/db/pkg/app-emulation/qemu-*/USE 1> /dev/null 2>&1) && grep -q static-user /var/db/pkg/app-emulation/qemu-*/USE ) && echo true || echo false)
readonly qemu_binfmt_is_running=$( { pidof systemd >/dev/null && systemctl is-active --quiet systemd-binfmt; } || { [[ -x /etc/init.d/qemu-binfmt ]] && /etc/init.d/qemu-binfmt status | grep -q started; } && echo true || echo false )
readonly catalyst_is_installed=$( which catalyst >/dev/null 2>&1 && echo true || echo false )
readonly yq_is_installed=$( which yq >/dev/null 2>&1 && echo true || echo false )
readonly git_is_installed=$( which git >/dev/null 2>&1 && echo true || echo false )
readonly git_lfs_is_installed=$( which git-lfs >/dev/null 2>&1 && echo true || echo false )
readonly squashfs_tools_is_installed=$( which mksquashfs >/dev/null 2>&1 && echo true || echo false )
readonly templates_path_exists=$( [[ -d ${templates_path} ]] && echo true || echo false )
sanity_checks_required="catalyst_is_installed yq_is_installed"
sanity_checks_optional="templates_path_exists qemu_is_installed qemu_has_static_user qemu_binfmt_is_running squashfs_tools_is_installed git_is_installed git_lfs_is_installed"
if [[ ${DEBUG} = true ]]; then
	echo_color ${color_turquoise_bold} "[ Global sanity checks ]"
fi
# Check tests required for overall script capabilities. Customized tests are also performed for stages selected to rebuild later.
validate_sanity_checks false "${DEBUG}" "${sanity_checks_required[@]}"
validate_sanity_checks true "${DEBUG}" "${sanity_checks_optional[@]}"
[[ ${DEBUG} = true ]] && echo ""

# ------------------------------------------------------------------------------
# Main program:

declare -A builds_status=() # Contains status of stages marked to build. success,failure,disabled

# Validate parameters
[[ ${UPLOAD_BINREPOS} = true ]] && [[ ! ${FETCH_FRESH_REPOS} = true ]] && echo "When using --upload-binrepos, it is mandatory to also use --update-repos. Exiting." && exit 1
[[ ${UPLOAD_RELREPOS} = true ]] && [[ ! ${FETCH_FRESH_REPOS} = true ]] && echo "When using --upload-releases, it is mandatory to also use --update-repos. Exiting." && exit 1

load_stages
validate_stages
[[ ${PREPARE} = true ]] || [[ ${FETCH_FRESH_SNAPSHOT} = true ]] && prepare_portage_snapshot
[[ ${PREPARE} = true ]] || [[ ${FETCH_FRESH_RELENG} = true ]] && prepare_releng
[[ ${FETCH_FRESH_REPOS} = true ]] || [[ ${PREPARE} = true ]] && fetch_repos
[[ ${UPLOAD_BINREPOS} = true ]] && [[ ! ${PREPARE} = true ]] && upload_binrepos
[[ ${UPLOAD_RELREPOS} = true ]] && [[ ! ${PREPARE} = true ]] && move_relrepos && upload_relrepos
[[ ${PREPARE} = true ]] && prepare_stages
[[ ${DEBUG} = true ]] && print_debug_stack
[[ ${BUILD} = true ]] && build_stages
[[ ${PURGE} = true ]] && purge_old_builds_and_isos
[[ ${PURGE} = true ]] && [[ ${UPLOAD_RELREPOS} = true ]] && upload_relrepos # Uploads changes after purge_old_builds_and_isos
[[ ${BUILD} = true ]] && report_status
[[ ${BUILD} = true ]] && [[ -d ${binhost_work_path} ]] && rm -rf ${binhost_work_path}
[[ ! ${BUILD} = true ]] && echo "To build selected stages use --build flag."

# TODO: (H) Add possibility to include shared files anywhere into spec files. So for example keep single list of basic installCD tools, and use them across all livecd specs.
# TODO: (H) Check if settings common_flags is also only allowed in stage1
# TODO: (H) Define parent property for setting source_subpath. Parent can be name of stage, full name of stage (including platform and release) or remote. With remote it can just specify word remote and automatically find version, it it can specify tarball name or even full URL.
# TODO: (H) Add possibility to define remote jobs in templates. Automatically added remote jobs are considered "virtual"
# TODO: (N) When purging too big packages, copy them somewhere else and restore after repo was uploaded.
# TODO: (N) Add functions to manage platforms, releases and stages - add new, edit config, print config, etc.
# TODO: (N) Working with distcc (including local)
# TODO: (N) Add checking for valid config entries in config files
# TODO: (N) Add validation that parent and children uses the same base architecture
# TODO: (L) Make it possible to work with hubs (git based) - adding hub from github link, pulling automatically changes, registering in shared hub list, detecting name collisions.
# TODO: (L) Validate if stage name starts with one of: stage[1-4], livecd-stage[1-2], binhost. Other names should be considered incorrect. Custom version stamp can still be set in stage.spec if needed.

